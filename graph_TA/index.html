<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threat Actor Knowledge Graph</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
    <script src="https://unpkg.com/graphology-layout-forceatlas2/dist/graphology-layout-forceatlas2.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0e14 0%, #111318 50%, #1a1e26 100%);
            color: #e0e6ed;
            height: 100vh;
            overflow: hidden;
            font-size: 14px;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .controls {
            background: linear-gradient(180deg, #1a1e26 0%, #161b22 100%);
            padding: 20px;
            border-right: 2px solid #30363d;
            width: 320px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            position: relative;
            transition: width 0.3s ease, padding 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .controls.collapsed {
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        .controls::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
        }

        .controls h2 {
            color: #f85149;
            margin-bottom: 20px;
            font-size: 16px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #30363d;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .panel-toggle-btn {
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            color: #f0f6fc;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .panel-toggle-btn:hover {
            background: #30363d;
            color: #7c3aed;
        }

        .panel-toggle-btn.collapsed {
            transform: rotate(180deg);
        }

        .panel-title {
            color: #f0f6fc;
            margin-bottom: 20px;
            font-size: 16px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 12px 0;
            border-bottom: 2px solid #30363d;
            background: linear-gradient(90deg, rgba(124, 58, 237, 0.1), rgba(248, 81, 73, 0.1));
            border-radius: 8px;
        }

        .panel-title i {
            color: #f85149;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(248, 81, 73, 0.5);
        }

        .panel-expand-btn {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(33, 38, 45, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            width: 44px;
            height: 44px;
            color: #f0f6fc;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .panel-expand-btn:hover {
            background: rgba(124, 58, 237, 0.95);
            border-color: #7c3aed;
            transform: translateX(2px);
        }

        .section-header {
            color: #7c3aed;
            font-size: 14px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-section {
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .filter-section-header {
            background: #21262d;
            color: #f0f6fc;
            padding: 12px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid #30363d;
        }

        .filter-section-content {
            padding: 16px;
        }

        .filter-group {
            margin-bottom: 16px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #f0f6fc;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-select, .filter-input {
            width: 100%;
            padding: 10px 12px;
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #e0e6ed;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .filter-select:focus, .filter-input:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.1);
            background-color: #1c2128;
        }

        .filter-checkboxes {
            max-height: 200px;
            overflow-y: auto;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .checkbox-item:hover {
            background: #21262d;
        }

        .checkbox-item:last-child {
            margin-bottom: 0;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 10px;
            accent-color: #7c3aed;
            transform: scale(1.1);
        }

        .checkbox-item label {
            font-size: 12px;
            margin-bottom: 0;
            font-family: 'JetBrains Mono', monospace;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            color: #e0e6ed;
        }

        .country-flag-small {
            font-size: 14px;
        }

        .category-icon-small {
            color: #7c3aed;
            font-size: 12px;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: radial-gradient(ellipse at center, #0a0e14 0%, #111318 70%, #1a1e26 100%);
            border-top: 1px solid #30363d;
            border-bottom: 1px solid #30363d;
        }

        .view-tabs {
            background: #161b22;
            border-bottom: 2px solid #30363d;
            padding: 0 20px;
            display: flex;
            gap: 2px;
        }

        .tab-btn {
            background: #21262d;
            border: none;
            border-radius: 8px 8px 0 0;
            padding: 12px 20px;
            color: #8b949e;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .tab-btn:hover {
            background: #30363d;
            color: #f0f6fc;
        }

        .tab-btn.active {
            background: #0d1117;
            color: #7c3aed;
            border-bottom: 2px solid #7c3aed;
        }

        .view-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .main-container .panel-expand-btn {
            position: absolute;
            top: 70px;
            left: 20px;
        }

        .graph-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .matrix-container {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
        }

        /* Enhanced Graph Styles */
        .graph-svg {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .graph-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            z-index: 100;
            max-width: 200px;
        }

        .control-btn {
            background: rgba(33, 38, 45, 0.9);
            border: 1px solid #30363d;
            border-radius: 8px;
            width: 40px;
            height: 40px;
            color: #f0f6fc;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
        }

        .control-btn:hover {
            background: #7c3aed;
            border-color: #7c3aed;
            transform: scale(1.05);
        }

        .control-btn.active {
            background: #7c3aed;
            border-color: #7c3aed;
        }

        .graph-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(33, 38, 45, 0.9);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(4px);
            z-index: 100;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            color: #f0f6fc;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #30363d;
        }

        .graph-stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(33, 38, 45, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 16px;
            backdrop-filter: blur(8px);
            z-index: 100;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .stats-header {
            color: #7c3aed;
            font-size: 12px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid #30363d;
            padding-bottom: 8px;
        }

        .graph-stats .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
        }

        .graph-stats .stat-item:last-child {
            margin-bottom: 0;
        }

        .graph-stats .stat-label {
            color: #f85149;
            font-weight: 500;
        }

        .graph-stats .stat-value {
            color: #58a6ff;
            font-weight: 600;
        }

        /* Node Styles */
        .node {
            cursor: pointer;
            stroke-width: 2px;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            transition: all 0.2s ease;
        }

        .node:hover {
            stroke-width: 3px;
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.5));
        }

        .node.selected {
            stroke: #7c3aed !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 12px rgba(124, 58, 237, 0.6));
        }

        .node-country {
            fill: #58a6ff;
            stroke: #1f6feb;
        }

        .node-category {
            stroke: #21262d;
        }

        .node-actor {
            stroke: #21262d;
        }

        /* Link Styles */
        .link {
            stroke-opacity: 0.4;
            stroke-width: 1.5px;
            transition: all 0.2s ease;
        }

        .link:hover {
            stroke-opacity: 0.8;
            stroke-width: 2.5px;
        }

        .link-country {
            stroke: #58a6ff;
            stroke-dasharray: 5,3;
        }

        .link-category {
            stroke: #8b949e;
        }

        /* Label Styles */
        .node-label {
            fill: #f0f6fc;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            opacity: 0.9;
        }

        .node-label-country {
            font-size: 12px;
            fill: #58a6ff;
        }

        .node-label-category {
            font-size: 11px;
            fill: #f85149;
        }

        .node-label-actor {
            font-size: 9px;
            fill: #e0e6ed;
        }

        /* Tooltip */
        .graph-tooltip {
            position: absolute;
            background: rgba(33, 38, 45, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #f0f6fc;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            backdrop-filter: blur(4px);
            z-index: 200;
        }

        /* Performance optimizations */
        .node-group {
            will-change: transform;
        }

        .link-group {
            will-change: auto;
        }

        .details-panel {
            width: 450px;
            background: linear-gradient(180deg, #1a1e26 0%, #161b22 100%);
            border-left: 2px solid #30363d;
            padding: 0;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            position: relative;
        }

        .details-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #45b7d1, #4ecdc4, #ff6b6b);
        }


        .details-panel h2 {
            color: #f85149;
            margin-bottom: 20px;
            font-size: 16px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #30363d;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .threat-actor-card {
            background: linear-gradient(135deg, #111318 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .threat-actor-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #f85149, #7c3aed, #58a6ff);
        }

        .actor-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .actor-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: linear-gradient(135deg, #f85149, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-weight: bold;
            font-size: 20px;
            font-family: 'JetBrains Mono', monospace;
            box-shadow: 0 2px 8px rgba(248, 81, 73, 0.3);
        }

        .actor-info h3 {
            color: #7c3aed;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
            font-family: 'JetBrains Mono', monospace;
        }

        .actor-family {
            color: #58a6ff;
            font-size: 13px;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            opacity: 0.8;
        }

        .actor-details {
            margin-top: 15px;
        }

        .detail-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 12px;
            background-color: #161b22;
            border-radius: 6px;
            border-left: 3px solid #7c3aed;
            transition: all 0.2s ease;
        }

        .detail-row:hover {
            background-color: #1c2128;
            transform: translateX(2px);
        }

        .detail-label {
            font-weight: 600;
            color: #f85149;
            min-width: 90px;
            margin-right: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .detail-value {
            color: #e0e6ed;
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .country-flag {
            width: 24px;
            height: auto;
            margin-right: 8px;
            border-radius: 2px;
        }

        .other-names {
            margin-top: 15px;
        }

        .other-names h4 {
            color: #7c3aed;
            font-size: 14px;
            margin-bottom: 12px;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .name-tag {
            display: inline-block;
            background-color: #30363d;
            color: #e0e6ed;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 11px;
            margin: 3px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #484f58;
            transition: all 0.2s ease;
        }

        .name-tag:hover {
            background-color: #7c3aed;
            color: white;
            transform: scale(1.05);
        }

        .no-selection {
            text-align: center;
            color: #666;
            font-style: italic;
            margin-top: 50px;
        }

        .controls-content {
            flex: 1;
            overflow-y: auto;
        }

        .social-links {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 20px 0;
            margin-top: 20px;
            border-top: 1px solid #30363d;
            background: linear-gradient(90deg, rgba(124, 58, 237, 0.05), rgba(248, 81, 73, 0.05));
            border-radius: 8px;
        }

        .social-link {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 50%;
            color: #8b949e;
            font-size: 16px;
            text-decoration: none;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .social-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .social-link[href*="securitybreak.io"]:hover {
            background: #7c3aed;
            border-color: #7c3aed;
            color: white;
        }

        .social-link[href*="linkedin.com"]:hover {
            background: #0077b5;
            border-color: #0077b5;
            color: white;
        }

        .social-link[href*="x.com"]:hover {
            background: #1da1f2;
            border-color: #1da1f2;
            color: white;
        }

        .social-link[href*="youtube.com"]:hover {
            background: #ff0000;
            border-color: #ff0000;
            color: white;
        }

        /* Table View Styles */
        .table-container {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            background: radial-gradient(ellipse at center, #0a0e14 0%, #111318 70%, #1a1e26 100%);
        }

        .table-header {
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 2px solid #30363d;
            padding-bottom: 20px;
        }

        .table-title-section {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 20px;
            position: relative;
        }

        .table-header h3 {
            color: #f0f6fc;
            font-size: 24px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .download-btn {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
            border: 1px solid #8b5cf6;
            border-radius: 8px;
            padding: 12px 20px;
            color: white;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            box-shadow: 0 2px 8px rgba(124, 58, 237, 0.2);
            position: absolute;
            right: 0;
        }

        .download-btn:hover {
            background: linear-gradient(135deg, #6d28d9 0%, #7c3aed 100%);
            border-color: #7c3aed;
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(124, 58, 237, 0.4);
        }

        .download-btn:active {
            transform: translateY(0);
        }

        .table-header h3 i {
            color: #7c3aed;
        }

        .table-description {
            color: #8b949e;
            font-size: 14px;
            font-style: italic;
        }

        .table-content {
            max-width: 100%;
            overflow-x: auto;
        }

        .markdown-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
            background: #0d1117;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .markdown-table th {
            background: #21262d;
            color: #f0f6fc;
            padding: 16px 20px;
            text-align: left;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #30363d;
        }

        .markdown-table td {
            padding: 14px 20px;
            border-bottom: 1px solid #30363d;
            color: #e0e6ed;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .markdown-table tr:hover {
            background: rgba(124, 58, 237, 0.1);
        }

        .markdown-table tbody tr {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .markdown-table tbody tr:hover {
            background: rgba(124, 58, 237, 0.2);
            transform: translateX(2px);
        }

        .markdown-table tbody tr.selected {
            background: rgba(124, 58, 237, 0.3);
            border-left: 4px solid #7c3aed;
        }

        .markdown-table tr:last-child td {
            border-bottom: none;
        }

        .table-section {
            margin-bottom: 40px;
        }

        .table-section h4 {
            color: #7c3aed;
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
        }


        /* Mobile and Responsive Design */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .controls {
                width: 100%;
                max-height: 200px;
                order: 2;
                padding: 15px;
            }
            
            .graph-container {
                height: 60vh;
                order: 1;
            }
            
            .details-panel {
                width: 100%;
                max-height: 300px;
                order: 3;
                padding: 15px;
            }
            
            .filter-checkboxes {
                max-height: 100px;
            }
        }

        @media (max-width: 768px) {
            .controls h2, .details-panel h2 {
                font-size: 14px;
            }
            
            .threat-actor-card, .actor-profile {
                padding: 15px;
            }
            
            .actor-icon {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .actor-info h3, .primary-name {
                font-size: 16px;
            }
            
            .detail-row {
                padding: 8px;
            }
            
            .details-panel {
                width: 100%;
            }
            
            .attribution-grid {
                grid-template-columns: 1fr;
            }
            
            .aliases-container {
                gap: 6px;
            }
            
            .alias-tag {
                font-size: 10px;
                padding: 4px 8px;
            }
        }

        /* Color Utility Classes for Icons */
        .text-red-500 { color: #ef4444; }
        .text-red-400 { color: #f87171; }
        .text-red-600 { color: #dc2626; }
        .text-green-500 { color: #10b981; }
        .text-green-400 { color: #34d399; }
        .text-green-600 { color: #059669; }
        .text-blue-500 { color: #3b82f6; }
        .text-blue-400 { color: #60a5fa; }
        .text-blue-600 { color: #2563eb; }
        .text-yellow-500 { color: #eab308; }
        .text-orange-500 { color: #f97316; }
        .text-purple-500 { color: #a855f7; }
        .text-gray-400 { color: #9ca3af; }
        .text-gray-500 { color: #6b7280; }

        /* Terminal-style Loading Animation */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-family: 'JetBrains Mono', monospace;
            color: #7c3aed;
        }

        .loading::after {
            content: '_';
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #111318;
        }

        ::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }

        /* Enhanced Threat Actor Profile Styles */
        .actor-profile {
            padding: 0;
        }

        .profile-section {
            margin-bottom: 20px;
            background: #0d1117;
            border: 2px solid #21262d;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .section-title {
            background: #21262d;
            color: #f0f6fc;
            padding: 15px 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0;
            border-bottom: 2px solid #30363d;
        }

        .section-content {
            padding: 20px;
        }

        .primary-header {
            background: #161b22;
            padding: 20px;
            text-align: center;
            border-bottom: 3px solid #21262d;
            position: relative;
        }

        .actor-name-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .threat-icon {
            font-size: 24px;
            color: #f85149;
        }

        .primary-name {
            font-size: 24px;
            font-weight: 700;
            color: #f0f6fc;
            font-family: 'JetBrains Mono', monospace;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .primary-subtitle {
            color: #8b949e;
            font-size: 14px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .attribution-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .attribution-row {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .attribution-row:hover {
            background: #1c2128;
            border-color: #484f58;
        }

        .attribution-icon {
            width: 32px;
            height: 32px;
            background: #21262d;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            border: 1px solid #30363d;
        }

        .attribution-icon i {
            color: #7c3aed;
            font-size: 14px;
        }

        .attribution-content {
            flex: 1;
        }

        .attribution-label {
            font-size: 11px;
            color: #8b949e;
            text-transform: uppercase;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .attribution-value {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 14px;
            font-family: 'JetBrains Mono', monospace;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .aliases-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .alias-tag {
            background: #21262d;
            color: #f0f6fc;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            border: 2px solid #30363d;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .alias-tag:hover {
            background: #7c3aed;
            border-color: #7c3aed;
            color: white;
            transform: scale(1.05);
        }

        .description-text {
            color: #f0f6fc;
            line-height: 1.7;
            font-size: 15px;
            margin-bottom: 0;
        }

        /* MITRE ATT&CK TTPs - Commented out for now
        .mitre-techniques {
            display: grid;
            gap: 8px;
        }

        .technique-item {
            background: #161b22;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #30363d;
            border-left: 5px solid;
            transition: all 0.2s ease;
        }

        .technique-item:hover {
            background: #1c2128;
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .technique-id {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 13px;
            margin-bottom: 6px;
        }

        .technique-name {
            color: #f0f6fc;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .technique-category {
            font-size: 11px;
            text-transform: uppercase;
            opacity: 0.8;
            margin-top: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 500;
        }

        /* MITRE ATT&CK Color Coding */
        .tactic-initial-access { border-left-color: #ff6b6b; }
        .tactic-initial-access .technique-id { color: #ff6b6b; }

        .tactic-execution { border-left-color: #4ecdc4; }
        .tactic-execution .technique-id { color: #4ecdc4; }

        .tactic-persistence { border-left-color: #45b7d1; }
        .tactic-persistence .technique-id { color: #45b7d1; }

        .tactic-privilege-escalation { border-left-color: #f39c12; }
        .tactic-privilege-escalation .technique-id { color: #f39c12; }

        .tactic-defense-evasion { border-left-color: #e74c3c; }
        .tactic-defense-evasion .technique-id { color: #e74c3c; }

        .tactic-credential-access { border-left-color: #9b59b6; }
        .tactic-credential-access .technique-id { color: #9b59b6; }

        .tactic-discovery { border-left-color: #f1c40f; }
        .tactic-discovery .technique-id { color: #f1c40f; }

        .tactic-lateral-movement { border-left-color: #2ecc71; }
        .tactic-lateral-movement .technique-id { color: #2ecc71; }

        .tactic-collection { border-left-color: #3498db; }
        .tactic-collection .technique-id { color: #3498db; }

        .tactic-command-control { border-left-color: #34495e; }
        .tactic-command-control .technique-id { color: #95a5a6; }

        .tactic-exfiltration { border-left-color: #e67e22; }
        .tactic-exfiltration .technique-id { color: #e67e22; }

        .tactic-impact { border-left-color: #c0392b; }
        .tactic-impact .technique-id { color: #c0392b; }
        */

        .no-data {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
            font-size: 13px;
        }

        /* Matrix/Card View Styles */
        .view-controls {
            background: #161b22;
            padding: 15px 20px;
            border-bottom: 1px solid #30363d;
            display: flex;
            gap: 10px;
        }

        .view-btn {
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 16px;
            color: #8b949e;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .view-btn:hover {
            background: #30363d;
            color: #f0f6fc;
        }

        .view-btn.active {
            background: #7c3aed;
            border-color: #7c3aed;
            color: white;
        }

        .country-section {
            margin-bottom: 30px;
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .country-header {
            background: linear-gradient(90deg, #21262d, #30363d);
            padding: 16px 24px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 14px;
            color: #f0f6fc;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 2px solid #30363d;
        }

        .country-flag {
            font-size: 20px;
        }

        .actor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            padding: 20px;
        }

        .actor-card {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .actor-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--category-color), var(--category-color)aa);
            opacity: 0.8;
        }

        .actor-card:hover {
            background: linear-gradient(135deg, #1c2128 0%, #161b22 100%);
            border-color: #484f58;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .actor-card.selected {
            border-color: #7c3aed;
            background: linear-gradient(135deg, #252033 0%, #1a1625 100%);
            box-shadow: 0 0 20px rgba(124, 58, 237, 0.3);
        }

        .actor-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }

        .actor-category-icon {
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--category-color);
            font-size: 16px;
            flex-shrink: 0;
        }

        .actor-info {
            flex: 1;
            min-width: 0;
        }

        .actor-name {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: #f0f6fc;
            font-size: 14px;
            line-height: 1.3;
            margin-bottom: 4px;
            word-break: break-word;
        }

        .actor-family {
            color: #8b949e;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            opacity: 0.9;
        }

        .actor-aliases {
            border-top: 1px solid #21262d;
            padding-top: 12px;
        }

        .actor-aliases-label {
            font-size: 10px;
            color: #8b949e;
            text-transform: uppercase;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .alias-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .alias-chip {
            background: #21262d;
            color: #e0e6ed;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #30363d;
            white-space: nowrap;
        }


        /* Threat Actors List Styles */
        .threat-actors-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .actor-list-item {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .actor-list-item:hover {
            background: #1c2128;
            border-color: #484f58;
            transform: translateX(2px);
        }

        .actor-item-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .actor-item-icon {
            width: 32px;
            height: 32px;
            background: #21262d;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #7c3aed;
            border: 1px solid #30363d;
        }

        .actor-item-info {
            flex: 1;
        }

        .actor-item-name {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: #f0f6fc;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .actor-item-details {
            font-size: 12px;
            color: #8b949e;
            font-family: 'JetBrains Mono', monospace;
        }

        .actor-item-aliases {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .alias-chip-small {
            background: #21262d;
            color: #e0e6ed;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #30363d;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
        }

        /* Reports Section Styles */
        .reports-container {
            margin-top: 8px;
        }

        .loading-reports, .no-reports, .error-reports {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #8b949e;
        }

        .loading-reports {
            background: #0d1117;
            border: 1px solid #21262d;
        }

        .no-reports {
            background: #161b22;
            border: 1px solid #30363d;
        }

        .error-reports {
            background: #2d1617;
            border: 1px solid #8e2633;
            color: #f85149;
        }

        .reports-list {
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #161b22;
        }

        .reports-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #30363d;
            background: #0d1117;
            border-radius: 6px 6px 0 0;
        }

        .reports-count {
            font-size: 12px;
            color: #8b949e;
            font-family: 'JetBrains Mono', monospace;
        }

        .orkl-link {
            color: #58a6ff;
            text-decoration: none;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: color 0.2s ease;
        }

        .orkl-link:hover {
            color: #79c0ff;
        }

        .report-item {
            padding: 12px;
            border-bottom: 1px solid #30363d;
            transition: background-color 0.2s ease;
        }

        .report-item:last-child {
            border-bottom: none;
        }

        .report-item:hover {
            background: #21262d;
        }

        .report-title {
            margin-bottom: 6px;
        }

        .report-title a {
            color: #f0f6fc;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            line-height: 1.4;
            display: block;
        }

        .report-title a:hover {
            color: #58a6ff;
            text-decoration: underline;
        }

        .report-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 11px;
            color: #8b949e;
            font-family: 'JetBrains Mono', monospace;
        }

        .report-id {
            opacity: 0.8;
        }

        .report-date {
            opacity: 0.7;
        }

        .reports-footer {
            padding: 12px;
            text-align: center;
            border-top: 1px solid #30363d;
            background: #0d1117;
            border-radius: 0 0 6px 6px;
        }

        .more-reports {
            font-size: 11px;
            color: #8b949e;
            font-style: italic;
        }

        .view-all-reports-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: #21262d;
            color: #58a6ff;
            text-decoration: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }

        .view-all-reports-btn:hover {
            background: #30363d;
            color: #79c0ff;
            border-color: #484f58;
        }

        .report-title-text {
            color: #f0f6fc;
            font-size: 13px;
            font-weight: 500;
            line-height: 1.4;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h1 class="panel-title">
                <i class="fas fa-skull"></i> Threat Actors Alias
            </h1>
            <h2>
                <i class="fas fa-filter"></i> Filters
                <button id="panel-toggle" class="panel-toggle-btn" title="Toggle Panel">
                    <i class="fas fa-chevron-left"></i>
                </button>
            </h2>
            
            <div class="controls-content">
                <!-- Basic Filters Section -->
                <div class="filter-section">
                    <div class="filter-section-header">
                        <i class="fas fa-search"></i>
                        Basic Filters
                    </div>
                    <div class="filter-section-content">
                        <div class="filter-group">
                            <label for="search">Search</label>
                            <input type="text" id="search" class="filter-input" placeholder="Search threat actors...">
                        </div>

                        <div class="filter-group">
                            <label for="familyFilter">Family</label>
                            <select id="familyFilter" class="filter-select">
                                <option value="">All Families</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Categories Section -->
                <div class="filter-section">
                    <div class="filter-section-header">
                        <i class="fas fa-tags"></i>
                        Categories
                    </div>
                    <div class="filter-section-content">
                        <div class="filter-group">
                            <label for="categoryFilter">Filter by Category</label>
                            <select id="categoryFilter" class="filter-select">
                                <option value="">All Categories</option>
                            </select>
                        </div>
                        <div id="categoryFilters" class="filter-checkboxes"></div>
                    </div>
                </div>

                <!-- Countries Section -->
                <div class="filter-section">
                    <div class="filter-section-header">
                        <i class="fas fa-globe"></i>
                        Countries
                    </div>
                    <div class="filter-section-content">
                        <div id="countryFilters" class="filter-checkboxes"></div>
                    </div>
                </div>
            </div>

            <!-- Social Links Section -->
            <div class="social-links">
                <a href="https://securitybreak.io/" target="_blank" rel="noopener noreferrer" class="social-link" title="Security Break Website">
                    <i class="fas fa-globe"></i>
                </a>
                <a href="https://www.linkedin.com/in/thomas-roccia/" target="_blank" rel="noopener noreferrer" class="social-link" title="LinkedIn Profile">
                    <i class="fab fa-linkedin"></i>
                </a>
                <a href="https://x.com/fr0gger_" target="_blank" rel="noopener noreferrer" class="social-link" title="Twitter/X Profile">
                    <i class="fab fa-twitter"></i>
                </a>
                <a href="https://www.youtube.com/@SecurityBreak" target="_blank" rel="noopener noreferrer" class="social-link" title="YouTube Channel">
                    <i class="fab fa-youtube"></i>
                </a>
            </div>

        </div>

        <div class="main-container">
            <button id="panel-expand" class="panel-expand-btn" title="Show Panel" style="display: none;">
                <i class="fas fa-chevron-right"></i>
            </button>
            <div class="view-tabs">
                <button class="tab-btn active" id="tab-graph">
                    <i class="fas fa-project-diagram"></i>
                    Graph View
                </button>
                <button class="tab-btn" id="tab-cards">
                    <i class="fas fa-th-large"></i>
                    Card View
                </button>
                <button class="tab-btn" id="tab-table">
                    <i class="fas fa-table"></i>
                    Table View
                </button>
            </div>
            
            <div class="view-content">
                <!-- Graph View -->
                <div id="graph-view" class="graph-container">
                    <div class="graph-controls">
                        <button class="control-btn active" id="layout-force" title="Force Layout">
                            <i class="fas fa-project-diagram"></i>
                        </button>
                        <button class="control-btn" id="layout-circular" title="Circular Layout">
                            <i class="fas fa-circle-notch"></i>
                        </button>
                        <button class="control-btn" id="layout-hierarchical" title="Hierarchical Layout">
                            <i class="fas fa-sitemap"></i>
                        </button>
                        <button class="control-btn" id="zoom-in" title="Zoom In">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <button class="control-btn" id="zoom-out" title="Zoom Out">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <button class="control-btn" id="zoom-fit" title="Fit to Screen">
                            <i class="fas fa-expand-arrows-alt"></i>
                        </button>
                        <button class="control-btn" id="physics-toggle" title="Toggle Physics Simulation">
                            <i class="fas fa-play"></i>
                        </button>
                    </div>
                    <div id="graph-cy" class="graph-svg"></div>
                    <div class="graph-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #58a6ff;"></div>
                            <span>Countries</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff1113;"></div>
                            <span>Nation-state</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #1318ff;"></div>
                            <span>Financially motivated</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #18ff11;"></div>
                            <span>Private sector</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff1114;"></div>
                            <span>Influence operations</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #888;"></div>
                            <span>Groups in development</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b1a;"></div>
                            <span>Covert network</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #666666;"></div>
                            <span>Unknown</span>
                        </div>
                    </div>
                    
                    <!-- Statistics Section -->
                    <div class="graph-stats">
                        <div class="stats-header"><i class="fas fa-chart-bar"></i> Statistics</div>
                        <div class="stat-item">
                            <span class="stat-label">Total Actors:</span>
                            <span class="stat-value" id="totalActors">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Visible:</span>
                            <span class="stat-value" id="visibleActors">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Countries:</span>
                            <span class="stat-value" id="totalCountries">0</span>
                        </div>
                    </div>
                </div>

                <!-- Card View -->
                <div id="cards-view" class="matrix-container" style="display: none;">
                    <div class="view-controls">
                        <button class="view-btn active" id="view-country">
                            <i class="fas fa-globe"></i>
                            By Country
                        </button>
                        <button class="view-btn" id="view-category">
                            <i class="fas fa-tags"></i>
                            By Category
                        </button>
                        <button class="view-btn" id="view-family">
                            <i class="fas fa-sitemap"></i>
                            By Family
                        </button>
                    </div>
                    <div id="matrix-container"></div>
                </div>

                <!-- Table View -->
                <div id="table-view" class="table-container" style="display: none;">
                    <div class="table-header">
                        <div class="table-title-section">
                            <h3><i class="fas fa-table"></i> Threat Actor Classification Table</h3>
                            <button id="download-btn" class="download-btn" title="Download Threat Actor Data">
                                <i class="fas fa-download"></i>
                                Download CSV
                            </button>
                        </div>
                        <div class="table-description">
                            Weather-themed naming convention and threat actor directory
                        </div>
                    </div>
                    <div class="table-content" id="table-content">
                        <!-- Table content will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="details-panel">
            <div id="actorDetails">
                <div class="no-selection">
                    <i class="fas fa-mouse-pointer" style="margin-bottom: 10px; font-size: 24px; color: #7c3aed;"></i><br>
                    <strong>Select a Threat Actor</strong><br>
                    <span style="font-size: 12px; opacity: 0.7;">Click on any node in the graph to view detailed intelligence</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        let threatActorsData = null;
        let graph = null;
        let sigma = null;
        let selectedNode = null;
        let panelCollapsed = false;

        // Country emoji flags for card view
        const countryFlags = {
            'China': '',
            'Iran': '',
            'Russia': '',
            'North Korea': '',
            'Lebanon': '',
            'South Korea': '',
            'Trkiye': '',
            'Vietnam': '',
            'Germany': '',
            'India': '',
            'Pakistan': '',
            'Palestinian Authority': '',
            'Singapore': '',
            'Spain': '',
            'Syria': '',
            'Ukraine': '',
            'United States': '',
            'Israel': '',
            'Austria': '',
            'Unknown': ''
        };

        // Country flag image URLs from Wikipedia
        const countryFlagImages = {
            'China': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Flag_of_the_People%27s_Republic_of_China.svg/32px-Flag_of_the_People%27s_Republic_of_China.svg.png',
            'Iran': 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Flag_of_Iran.svg/32px-Flag_of_Iran.svg.png',
            'Russia': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Flag_of_Russia.svg/32px-Flag_of_Russia.svg.png',
            'North Korea': 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Flag_of_North_Korea.svg/32px-Flag_of_North_Korea.svg.png',
            'Lebanon': 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/Flag_of_Lebanon.svg/32px-Flag_of_Lebanon.svg.png',
            'South Korea': 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Flag_of_South_Korea.svg/32px-Flag_of_South_Korea.svg.png',
            'Trkiye': 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Flag_of_Turkey.svg/32px-Flag_of_Turkey.svg.png',
            'Vietnam': 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Flag_of_Vietnam.svg/32px-Flag_of_Vietnam.svg.png',
            'Germany': 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/Flag_of_Germany.svg/32px-Flag_of_Germany.svg.png',
            'India': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Flag_of_India.svg/32px-Flag_of_India.svg.png',
            'Pakistan': 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Flag_of_Pakistan.svg/32px-Flag_of_Pakistan.svg.png',
            'Palestinian Authority': 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Flag_of_Palestine.svg/32px-Flag_of_Palestine.svg.png',
            'Singapore': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Flag_of_Singapore.svg/32px-Flag_of_Singapore.svg.png',
            'Spain': 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Flag_of_Spain.svg/32px-Flag_of_Spain.svg.png',
            'Syria': 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Flag_of_Syria.svg/32px-Flag_of_Syria.svg.png',
            'Ukraine': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/49/Flag_of_Ukraine.svg/32px-Flag_of_Ukraine.svg.png',
            'United States': 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Flag_of_the_United_States.svg/32px-Flag_of_the_United_States.svg.png',
            'Israel': 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Flag_of_Israel.svg/32px-Flag_of_Israel.svg.png',
            'Austria': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Flag_of_Austria.svg/32px-Flag_of_Austria.svg.png'
        };

        const categoryIcons = {
            'Nation-state': '<i class="fas fa-chess-king"></i>',
            'Financially motivated': '<i class="fas fa-dollar-sign"></i>',
            'Private sector offensive actor': '<i class="fas fa-building"></i>',
            'Influence operations': '<i class="fas fa-bullhorn"></i>',
            'Groups in development': '<i class="fas fa-flask"></i>',
            'Covert network': '<i class="fas fa-user-secret"></i>',
            'Unknown': '<i class="fas fa-question"></i>'
        };


        const familyIcons = {
            'Typhoon': '<i class="fas fa-wind"></i>',
            'Sandstorm': '<i class="fas fa-cloud-meatball"></i>',
            'Rain': '<i class="fas fa-cloud-rain"></i>',
            'Sleet': '<i class="fas fa-snowflake"></i>',
            'Blizzard': '<i class="fas fa-wind"></i>',
            'Hail': '<i class="fas fa-cloud-hail"></i>',
            'Dust': '<i class="fas fa-smog"></i>',
            'Cyclone': '<i class="fas fa-tornado"></i>',
            'Gale': '<i class="fas fa-wind"></i>',
            'Monsoon': '<i class="fas fa-cloud-showers-heavy"></i>',
            'Whirlwind': '<i class="fas fa-hurricane"></i>',
            'Lightning': '<i class="fas fa-bolt"></i>',
            'Squall': '<i class="fas fa-wind"></i>',
            'Derecho': '<i class="fas fa-wind"></i>',
            'Haze': '<i class="fas fa-smog"></i>',
            'Frost': '<i class="fas fa-icicles"></i>',
            'Tornado': '<i class="fas fa-tornado"></i>',
            'Tempest': '<i class="fas fa-cloud-bolt"></i>',
            'Tsunami': '<i class="fas fa-water"></i>',
            'Flood': '<i class="fas fa-house-flood"></i>',
            'Storm': '<i class="fas fa-cloud-bolt"></i>',
            'Special': '<i class="fas fa-mask"></i>'
        };

        // Category colors
        const categoryColors = {
            'Nation-state': '#ff1113',
            'Financially motivated': '#1318ff',
            'Private sector offensive actor': '#18ff11',
            'Influence operations': '#ff1114',
            'Groups in development': '#888',
            'Covert network': '#ff6b1a',
            'Unknown': '#666666'
        };


        // Category description mapping from JSON
        const categoryDescriptions = {
            'nation_state': 'Nation-state',
            'financially_motivated': 'Financially motivated',
            'private_sector_offensive': 'Private sector offensive actor',
            'influence_operations': 'Influence operations',
            'groups_in_development': 'Groups in development'
        };

        // Category detailed descriptions - populated from JSON
        let categoryDetailedDescriptions = {};

        async function loadThreatActorsData() {
            try {
                console.log('Attempting to load JSON...');
                const response = await fetch('threat_actors_naming.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                threatActorsData = await response.json();
                console.log('JSON loaded successfully:', threatActorsData);
                console.log('Number of threat actors:', threatActorsData.threat_actors?.length || 0);
                
                // Populate category descriptions from JSON
                if (threatActorsData.categories) {
                    categoryDetailedDescriptions = {
                        'Nation-state': threatActorsData.categories.nation_state?.description || 'Cyber operators acting on behalf of or directed by a nation/state-aligned program',
                        'Financially motivated': threatActorsData.categories.financially_motivated?.description || 'Criminal organizations/persons with financial gain motivations',
                        'Private sector offensive actor': threatActorsData.categories.private_sector_offensive?.description || 'Commercial actors that create and sell cyberweapons',
                        'Influence operations': threatActorsData.categories.influence_operations?.description || 'Information campaigns to shift perceptions and behaviors',
                        'Groups in development': threatActorsData.categories.groups_in_development?.description || 'Temporary designation for unknown, emerging, or developing threat activity',
                        'Covert network': 'Hidden networks operating under cover',
                        'Unknown': 'Threat actors with unidentified or unclassified motivations and affiliations'
                    };
                    console.log('Category descriptions loaded:', categoryDetailedDescriptions);
                }
                
                // Validate data structure
                if (!threatActorsData.threat_actors || !Array.isArray(threatActorsData.threat_actors)) {
                    throw new Error('Invalid data format: threat_actors array not found');
                }
                initializeGraph();
                populateFilters();
                updateStats();
                
                // If table view is currently visible, populate it
                if (document.getElementById('table-view').style.display === 'block') {
                    populateActorTable();
                }
            } catch (error) {
                console.error('Error loading threat actors data:', error);
                const errorContainer = document.getElementById('graph-svg') || document.getElementById('matrix-container');
                if (errorContainer) {
                    errorContainer.innerHTML = `
                        <div style="color: #f85149; padding: 40px; text-align: center; font-family: 'JetBrains Mono', monospace;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 20px;"></i><br>
                            <strong>DATA LOAD FAILED</strong><br>
                            <span style="font-size: 12px; opacity: 0.7;">${error.message}</span>
                        </div>`;
                }
            }
        }

        function initializeGraph() {
            console.log('Initializing visualization...');
            
            // Set up tab controls
            setupTabControls();
            
            // Set up view controls for card view
            setupCardViewControls();
            
            // Set up graph controls
            setupGraphControls();
            
            // Start with graph view as default
            showGraphView();
        }

        function setupTabControls() {
            document.getElementById('tab-graph').onclick = () => {
                console.log('Graph tab clicked');
                setActiveTab('graph');
                showGraphView();
            };
            
            document.getElementById('tab-cards').onclick = () => {
                console.log('Cards tab clicked');
                setActiveTab('cards');
                showCardView();
            };
            
            document.getElementById('tab-table').onclick = () => {
                console.log('Table tab clicked');
                setActiveTab('table');
                showTableView();
            };
        }

        function setActiveTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
        }

        function showGraphView() {
            document.getElementById('graph-view').style.display = 'block';
            document.getElementById('cards-view').style.display = 'none';
            document.getElementById('table-view').style.display = 'none';
            
            // Initialize graph if not already done
            if (!sigma) {
                setupSigmaGraph();
            } else {
                // Apply current filters to the graph
                updateGraphFilters();
            }
        }

        function showCardView() {
            document.getElementById('graph-view').style.display = 'none';
            document.getElementById('cards-view').style.display = 'block';
            document.getElementById('table-view').style.display = 'none';
            
            // Get current active card view or default to country
            const activeCardView = document.querySelector('.view-btn.active');
            if (activeCardView) {
                const viewType = activeCardView.id.replace('view-', '');
                if (viewType === 'country') {
                    renderByCountry();
                } else if (viewType === 'category') {
                    renderByCategory();
                } else if (viewType === 'family') {
                    renderByFamily();
                }
            } else {
                // Default to country view
                setActiveCardView('country');
                renderByCountry();
            }
        }

        function showTableView() {
            document.getElementById('graph-view').style.display = 'none';
            document.getElementById('cards-view').style.display = 'none';
            document.getElementById('table-view').style.display = 'block';
            
            // Always load table content to ensure it's up to date
            loadTableContent();
        }

        function loadTableContent() {
            const tableContent = document.getElementById('table-content');
            
            // Create the markdown content as HTML
            const htmlContent = `
                <div class="table-section">
                    <h4>Weather-Themed Naming Convention by Category</h4>
                    <table class="markdown-table">
                        <thead>
                            <tr>
                                <th>Category</th>
                                <th>Countries/Type</th>
                                <th>Weather Theme</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Nation-state</td>
                                <td>China, Iran, Lebanon, North Korea, Russia, South Korea, Trkiye, Vietnam</td>
                                <td>Typhoon, Sandstorm, Rain, Sleet, Blizzard, Hail, Dust, Cyclone</td>
                            </tr>
                            <tr>
                                <td>Nation-state (Extended)</td>
                                <td>China, Germany, India, Iran, North Korea, Lebanon, Pakistan, Palestinian Authority, Russia, Singapore, South Korea, Spain, Syria, Trkiye, Ukraine, United States, Vietnam</td>
                                <td>Typhoon, Gale, Monsoon, Sandstorm, Sleet, Rain, Whirlwind, Lightning, Blizzard, Squall, Hail, Derecho, Haze, Dust, Frost, Tornado, Cyclone</td>
                            </tr>
                            <tr>
                                <td>Financially motivated</td>
                                <td>Various</td>
                                <td>Tempest</td>
                            </tr>
                            <tr>
                                <td>Private sector offensive actors (PSOAs)</td>
                                <td>Various</td>
                                <td>Tsunami</td>
                            </tr>
                            <tr>
                                <td>Influence operations</td>
                                <td>Various</td>
                                <td>Flood</td>
                            </tr>
                            <tr>
                                <td>Groups in development</td>
                                <td>Various</td>
                                <td>Storm</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="table-section">
                    <h4>Threat Actor Directory</h4>
                    <table class="markdown-table">
                        <thead>
                            <tr>
                                <th>Threat Actor Name</th>
                                <th>Origin/Category</th>
                                <th>Other Names</th>
                            </tr>
                        </thead>
                        <tbody id="actor-table-body">
                            <!-- Will be populated dynamically from JSON data -->
                        </tbody>
                    </table>
                </div>
            `;
            
            tableContent.innerHTML = htmlContent;
            
            // Populate the actor table from the loaded data
            populateActorTable();
            
            // Setup download button
            setupDownloadButton();
            
        }

        function populateActorTable() {
            const tbody = document.getElementById('actor-table-body');
            console.log('Populating actor table, tbody:', tbody);
            console.log('threatActorsData:', threatActorsData);
            
            if (!tbody) {
                console.error('Actor table body not found');
                return;
            }
            
            if (!threatActorsData || !threatActorsData.threat_actors) {
                console.log('Threat actors data not loaded yet, showing placeholder');
                tbody.innerHTML = `
                    <tr>
                        <td colspan="3" style="text-align: center; font-style: italic; color: #8b949e;">
                            Loading threat actors data...
                        </td>
                    </tr>
                `;
                
                // Retry after a short delay if data is still loading
                setTimeout(() => {
                    if (threatActorsData && threatActorsData.threat_actors) {
                        populateActorTable();
                    }
                }, 1000);
                return;
            }
            
            // Sort actors alphabetically by name
            const sortedActors = [...threatActorsData.threat_actors].sort((a, b) => a.name.localeCompare(b.name));
            console.log('Sorted actors count:', sortedActors.length);
            
            tbody.innerHTML = sortedActors.map(actor => `
                <tr data-actor-name="${actor.name.replace(/"/g, '&quot;')}" onclick="selectTableActor('${actor.name.replace(/'/g, "\\'")}')">
                    <td><strong>${actor.name}</strong></td>
                    <td>${actor.origin} - ${actor.category}</td>
                    <td>${actor.other_names && actor.other_names.length > 0 ? actor.other_names.join(', ') : 'None'}</td>
                </tr>
            `).join('');
        }

        window.selectTableActor = function(actorName) {
            // Remove previous selection from table rows
            document.querySelectorAll('#actor-table-body tr').forEach(row => {
                row.classList.remove('selected');
            });
            
            // Add selection to clicked row
            const clickedRow = document.querySelector(`#actor-table-body tr[data-actor-name="${actorName.replace(/"/g, '&quot;')}"]`);
            if (clickedRow) {
                clickedRow.classList.add('selected');
            }
            
            // Find and display the actor data
            const actor = threatActorsData.threat_actors.find(a => a.name === actorName);
            if (actor) {
                displayActorDetails(actor);
                
                // Also update selected node for consistency with other views
                selectedNode = `actor_${actor.name}`;
            }
        }


        function setupDownloadButton() {
            const downloadBtn = document.getElementById('download-btn');
            if (downloadBtn) {
                downloadBtn.onclick = () => {
                    downloadThreatActorData();
                };
            }
        }

        function downloadThreatActorData() {
            if (!threatActorsData || !threatActorsData.threat_actors) {
                alert('Threat actor data not loaded yet. Please wait a moment and try again.');
                return;
            }

            // Create CSV content
            const csvContent = generateCSV();
            
            // Create and trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', 'threat_actors_data.csv');
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up the URL object
            URL.revokeObjectURL(url);
        }

        function generateCSV() {
            // CSV headers
            const headers = [
                'Threat Actor Name',
                'Origin/Country',
                'Category',
                'Family',
                'Other Names/Aliases'
            ];
            
            // Sort actors alphabetically
            const sortedActors = [...threatActorsData.threat_actors].sort((a, b) => a.name.localeCompare(b.name));
            
            // Generate CSV rows
            const csvRows = [
                // Header row
                headers.join(','),
                // Data rows
                ...sortedActors.map(actor => {
                    const row = [
                        `"${actor.name}"`,
                        `"${actor.origin}"`,
                        `"${actor.category}"`,
                        `"${actor.family}"`,
                        `"${actor.other_names && actor.other_names.length > 0 ? actor.other_names.join('; ') : 'None'}"`
                    ];
                    return row.join(',');
                })
            ];
            
            return csvRows.join('\n');
        }


        function setupCardViewControls() {
            document.getElementById('view-country').onclick = () => {
                setActiveCardView('country');
                renderByCountry();
            };
            
            document.getElementById('view-category').onclick = () => {
                setActiveCardView('category');
                renderByCategory();
            };
            
            document.getElementById('view-family').onclick = () => {
                setActiveCardView('family');
                renderByFamily();
            };
        }

        function setActiveCardView(view) {
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`view-${view}`).classList.add('active');
        }

        function setupSigmaGraph() {
            console.log('Setting up sigma.js graph...');
            const container = document.getElementById('graph-cy');
            if (!container) {
                console.error('Graph container not found');
                return;
            }
            
            // Ensure container has dimensions
            console.log('Container dimensions:', container.offsetWidth, 'x', container.offsetHeight);
            if (container.offsetWidth === 0 || container.offsetHeight === 0) {
                console.warn('Container has zero dimensions, setting default size');
                container.style.width = '800px';
                container.style.height = '600px';
            }
            
            try {
                // Check if libraries are properly loaded
                if (typeof graphology === 'undefined') {
                    throw new Error('Graphology library not loaded properly');
                }
                if (typeof Sigma === 'undefined') {
                    throw new Error('Sigma library not loaded properly');
                }
                
                // Create a new graphology graph
                graph = new graphology.Graph();
                
                // Build the graph data
                buildModernSigmaGraph();
                console.log('Graph built with', graph.order, 'nodes and', graph.size, 'edges');
                
                // Initialize sigma with the graph and container (following official documentation)
                const sigmaInstance = new Sigma(graph, container, {
                    labelFont: 'JetBrains Mono, monospace',
                    labelSize: 12,
                    labelWeight: '600',
                    labelColor: { color: '#ffffff' },
                    renderLabels: true,
                    renderEdgeLabels: false,
                    defaultNodeColor: '#7c3aed',
                    defaultEdgeColor: '#8b949e'
                });
                
                sigmaInstance.setSetting('defaultDrawNodeLabel', (context, data, settings) => {
                    if (data.hiddenLabel || !data.label) return;

                    const size = data.labelSize || settings.labelSize;
                    const font = settings.labelFont || 'sans-serif';
                    const weight = data.labelWeight || settings.labelWeight || 'normal';
                    const labelColor = data.labelColor || settings.labelColor.color || '#f0f6fc';

                    const offsetX = data.size + 8;
                    const offsetY = 0;

                    context.font = `${weight} ${size}px ${font}`;
                    context.textBaseline = 'middle';
                    context.textAlign = 'left';

                    const text = data.label;
                    const textWidth = context.measureText(text).width;

                    if (data.highlighted) {
                        // Draw dark box behind text
                        const padding = 4;
                        const boxX = data.x + offsetX - padding;
                        const boxY = data.y + offsetY - size / 2 - padding;
                        const boxW = textWidth + padding * 2;
                        const boxH = size + padding * 2;

                        context.fillStyle = 'rgba(0,0,0,0.8)';
                        context.fillRect(boxX, boxY, boxW, boxH);

                        // White text
                        context.fillStyle = '#ffffff';
                        context.fillText(text, data.x + offsetX, data.y + offsetY);
                    } else {
                        // Normal label
                        context.fillStyle = labelColor;
                        context.fillText(text, data.x + offsetX, data.y + offsetY);
                    }
                });



                sigma = sigmaInstance; // Store globally
                
                console.log('Sigma.js graph initialized');
                
                // Function to reset all highlighting and show all labels
                let highlightedNode = null;
                
                function resetHighlighting() {
                    if (highlightedNode === null) return;
                    
                    highlightedNode = null;
                    
                    // Reset all node colors and show all labels
                    graph.forEachNode((node) => {
                        const originalColor = graph.getNodeAttribute(node, 'originalColor') || '#7c3aed';
                        graph.setNodeAttribute(node, 'color', originalColor);
                        
                        // Restore original labels
                        const originalLabel = graph.getNodeAttribute(node, 'originalLabel');
                        if (originalLabel) {
                            graph.setNodeAttribute(node, 'label', originalLabel);
                        }
                        graph.setNodeAttribute(node, 'hiddenLabel', false); // Show all labels again
                    });
                    
                    // Reset all edge colors to original
                    graph.forEachEdge((edge) => {
                        const originalColor = graph.getEdgeAttribute(edge, 'originalColor') || '#8b949e';
                        graph.setEdgeAttribute(edge, 'color', originalColor);
                    });
                    
                    // Refresh the graph
                    sigma.refresh();
                }
                
                // Add click handler for different node types with label hiding
                sigma.on('clickNode', (event) => {
                    const nodeId = event.node;
                    const nodeData = graph.getNodeAttributes(nodeId);
                    
                    // If clicking the same node, reset highlighting and show all labels
                    if (highlightedNode === nodeId) {
                        resetHighlighting();
                        highlightedNode = null;
                        return;
                    }
                    
                    highlightedNode = nodeId;
                    
                    // Get neighboring nodes
                    const neighbors = new Set();
                    neighbors.add(nodeId); // Include the clicked node
                    
                    // Find all neighbors of the clicked node
                    graph.forEachNeighbor(nodeId, (neighbor) => {
                        neighbors.add(neighbor);
                    });
                    
                    // Update node appearance and hide unconnected labels
                    graph.forEachNode((node) => {
                        if (neighbors.has(node)) {
                            // Keep original color and show labels for connected nodes
                            graph.setNodeAttribute(node, 'color', graph.getNodeAttribute(node, 'originalColor'));
                            // Restore original label
                            const originalLabel = graph.getNodeAttribute(node, 'originalLabel') || graph.getNodeAttribute(node, 'label');
                            graph.setNodeAttribute(node, 'label', originalLabel);
                            graph.setNodeAttribute(node, 'hiddenLabel', false);
                        } else {
                            // Dim non-neighboring nodes and hide their labels
                            graph.setNodeAttribute(node, 'color', '#404040');
                            // Store original label if not already stored
                            if (!graph.getNodeAttribute(node, 'originalLabel')) {
                                graph.setNodeAttribute(node, 'originalLabel', graph.getNodeAttribute(node, 'label'));
                            }
                            // Hide label by setting it to empty string
                            graph.setNodeAttribute(node, 'label', '');
                            graph.setNodeAttribute(node, 'hiddenLabel', true);
                        }
                    });
                    
                    // Update edge colors
                    graph.forEachEdge((edge) => {
                        const source = graph.source(edge);
                        const target = graph.target(edge);
                        
                        if (neighbors.has(source) && neighbors.has(target)) {
                            // Keep original color for connected edges
                            graph.setEdgeAttribute(edge, 'color', graph.getEdgeAttribute(edge, 'originalColor'));
                        } else {
                            // Dim non-connected edges
                            graph.setEdgeAttribute(edge, 'color', '#404040');
                        }
                    });
                    
                    // Force refresh to show changes including label updates
                    sigma.refresh();
                    sigma.getCamera().animate({ x: sigma.getCamera().x, y: sigma.getCamera().y }, { duration: 1 });
                    
                    // Handle node type specific actions
                    if (nodeData.nodeType === 'actor' && nodeData.actorData) {
                        selectGraphActor(nodeData.actorData);
                    } else if (nodeData.nodeType === 'country') {
                        selectCountry(nodeId);
                    } else if (nodeData.nodeType === 'category') {
                        selectCategory(nodeId);
                    }
                });
                
                // Add hover effects for label color change and node highlighting
                sigma.on('enterNode', (event) => {
                    const nodeId = event.node;
                    // Only apply hover effect if this node is not part of current selection highlighting
                    if (highlightedNode === null || nodeId === highlightedNode || graph.neighbors(highlightedNode).includes(nodeId)) {
                        graph.setNodeAttribute(nodeId, 'highlighted', true);
                        graph.setNodeAttribute(nodeId, 'color', '#58a6ff'); // Blue color for hover (better contrast)
                        sigma.refresh();
                    }
                });
                
                sigma.on('leaveNode', (event) => {
                    const nodeId = event.node;
                    
                    // Only restore color if not part of current selection highlighting
                    if (highlightedNode === null) {
                        // No selection active - restore original color
                        const originalColor = graph.getNodeAttribute(nodeId, 'originalColor') || '#7c3aed';
                        graph.setNodeAttribute(nodeId, 'highlighted', false);
                        graph.setNodeAttribute(nodeId, 'color', originalColor);
                    } else if (nodeId === highlightedNode || graph.neighbors(highlightedNode).includes(nodeId)) {
                        // This node is part of selection - restore to highlighted state
                        const originalColor = graph.getNodeAttribute(nodeId, 'originalColor') || '#7c3aed';
                        graph.setNodeAttribute(nodeId, 'highlighted', false);
                        graph.setNodeAttribute(nodeId, 'color', originalColor);
                    } else {
                        // This node should remain dimmed as part of selection
                        graph.setNodeAttribute(nodeId, 'highlighted', false);
                        graph.setNodeAttribute(nodeId, 'color', '#404040');
                    }
                    sigma.refresh();
                });
                
                // Add enhanced drag functionality
                let isDragging = false;
                let draggedNode = null;
                let mousePos = null;
                
                // Handle mouse down on node
                sigma.on('downNode', (event) => {
                    isDragging = true;
                    draggedNode = event.node;
                    
                    // Store the initial mouse position
                    mousePos = { x: event.event.x, y: event.event.y };
                    
                    // Prevent camera interactions during drag
                    event.preventSigmaDefault();
                    event.original.preventDefault();
                    event.original.stopPropagation();
                });
                
                // Handle mouse move - physics-based force influence on connected nodes
                sigma.getMouseCaptor().on('mousemove', (event) => {
                    if (isDragging && draggedNode) {
                        // Convert screen coordinates to graph coordinates
                        const graphPos = sigma.viewportToGraph({ x: event.x, y: event.y });
                        
                        // Get previous position for velocity calculation
                        const oldX = graph.getNodeAttribute(draggedNode, 'x');
                        const oldY = graph.getNodeAttribute(draggedNode, 'y');
                        
                        // Update dragged node position
                        graph.setNodeAttribute(draggedNode, 'x', graphPos.x);
                        graph.setNodeAttribute(draggedNode, 'y', graphPos.y);
                        
                        // Calculate drag velocity for physics influence
                        const dragVelocityX = graphPos.x - oldX;
                        const dragVelocityY = graphPos.y - oldY;
                        
                        // Apply force influence to connected nodes using spring physics
                        const influenceRadius = 800; // Maximum distance for force influence
                        const springConstant = 0.04; // Spring stiffness - lower for more organic movement
                        const dampingFactor = 0.82; // Velocity damping
                        
                        // Get all connected nodes and apply force
                        const connectedNodes = new Set();
                        graph.forEachNeighbor(draggedNode, (neighbor) => {
                            connectedNodes.add(neighbor);
                        });
                        
                        // Apply physics-based force influence with collision detection
                        connectedNodes.forEach(nodeId => {
                            const nodeX = graph.getNodeAttribute(nodeId, 'x');
                            const nodeY = graph.getNodeAttribute(nodeId, 'y');
                            
                            // Calculate distance and direction to dragged node
                            const dx = graphPos.x - nodeX;
                            const dy = graphPos.y - nodeY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 0 && distance < influenceRadius) {
                                // Calculate desired distance (spring rest length)
                                const desiredDistance = 450; // Preferred distance between connected nodes
                                const displacement = distance - desiredDistance;
                                
                                // Calculate spring force
                                const forceX = (dx / distance) * displacement * springConstant;
                                const forceY = (dy / distance) * displacement * springConstant;
                                
                                // Get current velocity or initialize
                                let velocityX = graph.getNodeAttribute(nodeId, 'vx') || 0;
                                let velocityY = graph.getNodeAttribute(nodeId, 'vy') || 0;
                                
                                // Add drag influence to velocity
                                velocityX += dragVelocityX * 0.3 + forceX;
                                velocityY += dragVelocityY * 0.3 + forceY;
                                
                                // Apply damping
                                velocityX *= dampingFactor;
                                velocityY *= dampingFactor;
                                
                                // Calculate proposed new position
                                let newX = nodeX + velocityX;
                                let newY = nodeY + velocityY;
                                
                                // Collision detection and overlap prevention
                                const minNodeDistance = 120; // Minimum distance between any two nodes
                                let hasCollision = false;
                                
                                // Check for collisions with all other nodes
                                graph.forEachNode((otherNodeId) => {
                                    if (otherNodeId === nodeId) return;
                                    
                                    const otherX = graph.getNodeAttribute(otherNodeId, 'x');
                                    const otherY = graph.getNodeAttribute(otherNodeId, 'y');
                                    const distToOther = Math.sqrt((newX - otherX) ** 2 + (newY - otherY) ** 2);
                                    
                                    if (distToOther < minNodeDistance) {
                                        hasCollision = true;
                                        
                                        // Calculate repulsion vector
                                        const repulsionDx = newX - otherX;
                                        const repulsionDy = newY - otherY;
                                        const repulsionLength = Math.sqrt(repulsionDx ** 2 + repulsionDy ** 2);
                                        
                                        if (repulsionLength > 0) {
                                            // Push the node away to maintain minimum distance
                                            const pushDistance = minNodeDistance - repulsionLength + 10;
                                            newX = otherX + (repulsionDx / repulsionLength) * (minNodeDistance + 10);
                                            newY = otherY + (repulsionDy / repulsionLength) * (minNodeDistance + 10);
                                        }
                                    }
                                });
                                
                                // Limit maximum movement per frame to prevent wild swings
                                const maxMovement = 50;
                                const movementDist = Math.sqrt((newX - nodeX) ** 2 + (newY - nodeY) ** 2);
                                if (movementDist > maxMovement) {
                                    const moveX = newX - nodeX;
                                    const moveY = newY - nodeY;
                                    newX = nodeX + (moveX / movementDist) * maxMovement;
                                    newY = nodeY + (moveY / movementDist) * maxMovement;
                                    
                                    // Reduce velocity when capping movement
                                    velocityX *= 0.5;
                                    velocityY *= 0.5;
                                }
                                
                                graph.setNodeAttribute(nodeId, 'x', newX);
                                graph.setNodeAttribute(nodeId, 'y', newY);
                                graph.setNodeAttribute(nodeId, 'vx', velocityX);
                                graph.setNodeAttribute(nodeId, 'vy', velocityY);
                            }
                        });
                        
                        // Apply secondary influence with collision detection
                        const secondaryInfluence = 0.08;
                        const minSecondaryDistance = 100;
                        
                        connectedNodes.forEach(primaryNode => {
                            graph.forEachNeighbor(primaryNode, (secondaryNode) => {
                                if (secondaryNode !== draggedNode && !connectedNodes.has(secondaryNode)) {
                                    const primX = graph.getNodeAttribute(primaryNode, 'x');
                                    const primY = graph.getNodeAttribute(primaryNode, 'y');
                                    const secX = graph.getNodeAttribute(secondaryNode, 'x');
                                    const secY = graph.getNodeAttribute(secondaryNode, 'y');
                                    
                                    const dx = primX - secX;
                                    const dy = primY - secY;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance > 0 && distance < 500) {
                                        const forceX = (dx / distance) * secondaryInfluence;
                                        const forceY = (dy / distance) * secondaryInfluence;
                                        
                                        let newX = secX + forceX;
                                        let newY = secY + forceY;
                                        
                                        // Check for collisions and maintain minimum distance
                                        let hasCollision = false;
                                        graph.forEachNode((otherNodeId) => {
                                            if (otherNodeId === secondaryNode) return;
                                            
                                            const otherX = graph.getNodeAttribute(otherNodeId, 'x');
                                            const otherY = graph.getNodeAttribute(otherNodeId, 'y');
                                            const distToOther = Math.sqrt((newX - otherX) ** 2 + (newY - otherY) ** 2);
                                            
                                            if (distToOther < minSecondaryDistance) {
                                                hasCollision = true;
                                                // Don't apply the force if it would cause overlap
                                                newX = secX;
                                                newY = secY;
                                                return;
                                            }
                                        });
                                        
                                        if (!hasCollision) {
                                            graph.setNodeAttribute(secondaryNode, 'x', newX);
                                            graph.setNodeAttribute(secondaryNode, 'y', newY);
                                        }
                                    }
                                }
                            });
                        });
                        
                        // Refresh sigma to show the changes
                        sigma.refresh();
                        
                        // Prevent camera from moving
                        event.preventDefault();
                        event.stopPropagation();
                    }
                });
                
                // Physics simulation variables
                let isSimulating = false;
                let simulationId = null;
                
                // Handle mouse up - simple drag end
                sigma.getMouseCaptor().on('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        draggedNode = null;
                    }
                });
                
                // Also handle mouse leave to end dragging
                sigma.getMouseCaptor().on('mouseleave', () => {
                    if (isDragging) {
                        isDragging = false;
                        draggedNode = null;
                    }
                });
                
                // Continuous physics simulation with inertia
                function startPhysicsSimulation() {
                    if (isSimulating) return;
                    
                    isSimulating = true;
                    const nodes = graph.nodes();
                    const edges = graph.edges();
                    
                    // Initialize velocities if not present
                    nodes.forEach(node => {
                        if (!graph.hasNodeAttribute(node, 'vx')) {
                            graph.setNodeAttribute(node, 'vx', 0);
                        }
                        if (!graph.hasNodeAttribute(node, 'vy')) {
                            graph.setNodeAttribute(node, 'vy', 0);
                        }
                    });
                    
                    // Physics parameters for continuous simulation
                    const k = Math.sqrt(36000000 / nodes.length); // Extreme ideal distance for maximum cluster separation
                    const repulsionStrength = 1200; // Increased to prevent overlap
                    const attractionStrength = 0.02; // Minimal attraction to stay in place
                    const damping = 0.75; // Lower damping for gentle settling
                    const minVelocity = 2.0; // Higher threshold to stop simulation quickly
                    
                    function simulationStep() {
                        if (!isSimulating) return;
                        
                        let maxVelocity = 0;
                        
                        // Reset forces
                        nodes.forEach(node => {
                            graph.setNodeAttribute(node, 'fx', 0);
                            graph.setNodeAttribute(node, 'fy', 0);
                        });
                        
                        // Repulsive forces between nearby nodes
                        for (let i = 0; i < nodes.length; i++) {
                            for (let j = i + 1; j < nodes.length; j++) {
                                const node1 = nodes[i];
                                const node2 = nodes[j];
                                
                                const x1 = graph.getNodeAttribute(node1, 'x');
                                const y1 = graph.getNodeAttribute(node1, 'y');
                                const x2 = graph.getNodeAttribute(node2, 'x');
                                const y2 = graph.getNodeAttribute(node2, 'y');
                                
                                const dx = x1 - x2;
                                const dy = y1 - y2;
                                const distance = Math.sqrt(dx * dx + dy * dy) || 0.01;
                                
                                // Calculate minimum distance based on node sizes - strong collision detection
                                const node1Size = graph.getNodeAttribute(node1, 'size') || 15;
                                const node2Size = graph.getNodeAttribute(node2, 'size') || 15;
                                const minDistance = (node1Size + node2Size) * 3.5; // Much larger collision boundary
                                
                                if (distance < Math.max(k * 1.2, minDistance)) {
                                    let force = repulsionStrength / (distance * distance);
                                    
                                    // Very gentle repulsion scaling for nodes getting too close
                                    if (distance < minDistance) {
                                        const overlapRatio = (minDistance - distance) / minDistance;
                                        force *= (1 + overlapRatio * 1.5); // Gentle scaling from 1x to 2.5x
                                    }
                                    
                                    // Minimal emergency separation for actual overlap
                                    if (distance < (node1Size + node2Size) * 1.05) {
                                        force *= 1.5; // Very gentle boost for overlap
                                    }
                                    
                                    const fx = (dx / distance) * force;
                                    const fy = (dy / distance) * force;
                                    
                                    graph.setNodeAttribute(node1, 'fx', graph.getNodeAttribute(node1, 'fx') + fx);
                                    graph.setNodeAttribute(node1, 'fy', graph.getNodeAttribute(node1, 'fy') + fy);
                                    graph.setNodeAttribute(node2, 'fx', graph.getNodeAttribute(node2, 'fx') - fx);
                                    graph.setNodeAttribute(node2, 'fy', graph.getNodeAttribute(node2, 'fy') - fy);
                                }
                            }
                        }
                        
                        // Attractive forces for connected nodes
                        edges.forEach(edge => {
                            const source = graph.source(edge);
                            const target = graph.target(edge);
                            
                            const x1 = graph.getNodeAttribute(source, 'x');
                            const y1 = graph.getNodeAttribute(source, 'y');
                            const x2 = graph.getNodeAttribute(target, 'x');
                            const y2 = graph.getNodeAttribute(target, 'y');
                            
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const distance = Math.sqrt(dx * dx + dy * dy) || 0.01;
                            
                            const force = attractionStrength * (distance - k);
                            const fx = (dx / distance) * force;
                            const fy = (dy / distance) * force;
                            
                            graph.setNodeAttribute(source, 'fx', graph.getNodeAttribute(source, 'fx') + fx);
                            graph.setNodeAttribute(source, 'fy', graph.getNodeAttribute(source, 'fy') + fy);
                            graph.setNodeAttribute(target, 'fx', graph.getNodeAttribute(target, 'fx') - fx);
                            graph.setNodeAttribute(target, 'fy', graph.getNodeAttribute(target, 'fy') - fy);
                        });
                        
                        // Update velocities and positions with inertia
                        nodes.forEach(node => {
                            const fx = graph.getNodeAttribute(node, 'fx');
                            const fy = graph.getNodeAttribute(node, 'fy');
                            
                            let vx = graph.getNodeAttribute(node, 'vx');
                            let vy = graph.getNodeAttribute(node, 'vy');
                            
                            // Apply forces to velocity with reduced impact
                            vx += fx * 0.008;
                            vy += fy * 0.008;
                            
                            // Apply damping (inertia gradually slows down)
                            vx *= damping;
                            vy *= damping;
                            
                            // Track maximum velocity for stopping condition
                            const velocity = Math.sqrt(vx * vx + vy * vy);
                            maxVelocity = Math.max(maxVelocity, velocity);
                            
                            // Update position
                            const x = graph.getNodeAttribute(node, 'x') + vx;
                            const y = graph.getNodeAttribute(node, 'y') + vy;
                            
                            graph.setNodeAttribute(node, 'x', x);
                            graph.setNodeAttribute(node, 'y', y);
                            graph.setNodeAttribute(node, 'vx', vx);
                            graph.setNodeAttribute(node, 'vy', vy);
                        });
                        
                        // Update display
                        sigma.refresh();
                        
                        // Continue simulation if there's still significant movement
                        if (maxVelocity > minVelocity) {
                            simulationId = requestAnimationFrame(simulationStep);
                        } else {
                            // Stop simulation when movement becomes minimal
                            isSimulating = false;
                            simulationId = null;
                            
                            // Clean up force attributes
                            nodes.forEach(node => {
                                graph.removeNodeAttribute(node, 'fx');
                                graph.removeNodeAttribute(node, 'fy');
                            });
                        }
                    }
                    
                    // Start the simulation loop
                    simulationId = requestAnimationFrame(simulationStep);
                }
                
                // Stop simulation when user starts dragging again
                sigma.on('downNode', () => {
                    if (isSimulating) {
                        isSimulating = false;
                        if (simulationId) {
                            cancelAnimationFrame(simulationId);
                            simulationId = null;
                        }
                    }
                });
                
                
                // Handle stage clicks to reset highlighting
                sigma.on('clickStage', () => {
                    resetHighlighting();
                });
                
                
                // Apply force-directed layout with visible clusters
                startForceAtlas2Layout();
                
            } catch (error) {
                console.error('Error setting up sigma.js:', error);
                console.error('Error details:', error.message, error.stack);
                
                // Show error in container
                container.innerHTML = `
                    <div style="color: #f85149; padding: 40px; text-align: center; font-family: 'JetBrains Mono', monospace;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 20px;"></i><br>
                        <strong>GRAPH INITIALIZATION FAILED</strong><br>
                        <span style="font-size: 12px; opacity: 0.7;">${error.message}</span>
                    </div>`;
            }
        }

        function buildModernSigmaGraph() {
            if (!threatActorsData || !graph) {
                console.error('Missing threat actors data or graph instance');
                return;
            }
            
            console.log('Building modern sigma graph with', threatActorsData.threat_actors.length, 'actors');
            
            try {
                // Add country nodes
                const countries = [...new Set(threatActorsData.threat_actors.map(actor => actor.origin))];
                console.log('Adding', countries.length, 'countries');
                countries.forEach(country => {
                    graph.addNode(`country_${country}`, {
                        label: country,
                        size: 30,
                        color: '#58a6ff',
                        originalColor: '#58a6ff', // Store original color
                        labelWeight: 'bold', // Make country labels bold
                        labelSize: 20, // Larger font size for countries
                        labelColor: '#58a6ff', // Blue color for country labels
                        nodeType: 'country',
                        x: (Math.random() - 0.5) * 16000,
                        y: (Math.random() - 0.5) * 12000
                    });
                });
                
                // Add category nodes  
                const categories = [...new Set(threatActorsData.threat_actors.map(actor => actor.category))];
                console.log('Adding', categories.length, 'categories');
                categories.forEach(category => {
                    const categoryColor = categoryColors[category] || '#f85149';
                    graph.addNode(`category_${category}`, {
                        label: category,
                        size: 25,
                        color: categoryColor,
                        originalColor: categoryColor, // Store original color
                        labelWeight: 'bold', // Make category labels bold
                        labelSize: 15, // Larger font size for categories
                        labelColor: '#58a6ff', // Blue color for category labels
                        nodeType: 'category',
                        x: (Math.random() - 0.5) * 16000,
                        y: (Math.random() - 0.5) * 12000
                    });
                });
                
                // Add actor nodes
                console.log('Adding', threatActorsData.threat_actors.length, 'actors');
                threatActorsData.threat_actors.forEach(actor => {
                    const actorColor = categoryColors[actor.category] || '#7c3aed';
                    graph.addNode(`actor_${actor.name}`, {
                        label: actor.name,
                        size: 15,
                        color: actorColor,
                        originalColor: actorColor, // Store original color
                        labelWeight: 'normal', // Store original weight
                        nodeType: 'actor',
                        actorData: actor,
                        x: (Math.random() - 0.5) * 16000,
                        y: (Math.random() - 0.5) * 12000
                    });
                    
                    // Add edges - only connect actors to countries, not to categories
                    try {
                        graph.addEdge(`actor_${actor.name}`, `country_${actor.origin}`, {
                            color: '#58a6ff',
                            originalColor: '#58a6ff', // Store original color
                            size: 2,
                            edgeType: 'country'
                        });
                        
                        graph.addEdge(`actor_${actor.name}`, `category_${actor.category}`, {
                            color: '#f85149',
                            originalColor: '#f85149', // Store original color
                            size: 2,
                            edgeType: 'category'
                        });
                    } catch (e) {
                        console.warn('Error adding edge for actor:', actor.name, e);
                    }
                });
                
                console.log('Graph building complete');
                
            } catch (error) {
                console.error('Error building graph:', error);
            }
        }

        function setupGraphControls() {
            // Layout controls
            document.getElementById('layout-force').onclick = () => {
                setActiveLayout('force');
                startForceAtlas2Layout();
            };
            
            document.getElementById('layout-circular').onclick = () => {
                setActiveLayout('circular');
                applyCircularLayout();
            };
            
            document.getElementById('layout-hierarchical').onclick = () => {
                setActiveLayout('hierarchical');
                applyHierarchicalLayout();
            };
            
            // Zoom controls for modern Sigma
            document.getElementById('zoom-in').onclick = () => {
                if (sigma) {
                    const camera = sigma.getCamera();
                    camera.animatedZoom(1.5);
                }
            };
            
            document.getElementById('zoom-out').onclick = () => {
                if (sigma) {
                    const camera = sigma.getCamera();
                    camera.animatedZoom(0.5);
                }
            };
            
            document.getElementById('zoom-fit').onclick = () => {
                if (sigma) {
                    const camera = sigma.getCamera();
                    camera.animatedReset();
                }
            };
            
            // Physics simulation toggle
            let isPhysicsRunning = false;
            let physicsInterval = null;
            
            document.getElementById('physics-toggle').onclick = () => {
                const btn = document.getElementById('physics-toggle');
                const icon = btn.querySelector('i');
                
                if (isPhysicsRunning) {
                    // Stop physics simulation
                    if (physicsInterval) {
                        clearInterval(physicsInterval);
                        physicsInterval = null;
                    }
                    isPhysicsRunning = false;
                    icon.className = 'fas fa-play';
                    btn.title = 'Start Physics Simulation';
                    console.log('Physics simulation stopped');
                } else {
                    // Start continuous physics simulation
                    physicsInterval = setInterval(() => {
                        if (graph && sigma) {
                            runPhysicsStep();
                        }
                    }, 50); // Run physics at 20 FPS
                    
                    isPhysicsRunning = true;
                    icon.className = 'fas fa-pause';
                    btn.title = 'Stop Physics Simulation';
                    console.log('Physics simulation started');
                }
            };
        }

        function runPhysicsStep() {
            if (!graph || !sigma) return;
            
            const nodes = graph.nodes();
            const springLength = 480;
            const springStiffness = 0.01;
            const repulsionStrength = 8000;
            const damping = 0.85;
            
            // Apply forces to all nodes
            nodes.forEach(nodeA => {
                const posA = { x: graph.getNodeAttribute(nodeA, 'x'), y: graph.getNodeAttribute(nodeA, 'y') };
                let vx = graph.getNodeAttribute(nodeA, 'vx') || 0;
                let vy = graph.getNodeAttribute(nodeA, 'vy') || 0;
                let fx = 0, fy = 0;
                
                // Repulsion from all other nodes
                nodes.forEach(nodeB => {
                    if (nodeA === nodeB) return;
                    const posB = { x: graph.getNodeAttribute(nodeB, 'x'), y: graph.getNodeAttribute(nodeB, 'y') };
                    const dx = posA.x - posB.x;
                    const dy = posA.y - posB.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) + 1;
                    const force = repulsionStrength / (distance * distance);
                    fx += (dx / distance) * force;
                    fy += (dy / distance) * force;
                });
                
                // Attraction from connected nodes
                graph.forEachNeighbor(nodeA, (neighbor) => {
                    const posB = { x: graph.getNodeAttribute(neighbor, 'x'), y: graph.getNodeAttribute(neighbor, 'y') };
                    const dx = posB.x - posA.x;
                    const dy = posB.y - posA.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const displacement = distance - springLength;
                    const force = springStiffness * displacement;
                    fx += (dx / distance) * force;
                    fy += (dy / distance) * force;
                });
                
                // Update velocity and position with collision detection
                vx = (vx + fx) * damping;
                vy = (vy + fy) * damping;
                
                // Calculate proposed new position
                let newX = posA.x + vx;
                let newY = posA.y + vy;
                
                // Collision detection for real-time physics
                const minDistance = 120;
                graph.forEachNode((nodeB) => {
                    if (nodeA === nodeB) return;
                    
                    const posB = { x: graph.getNodeAttribute(nodeB, 'x'), y: graph.getNodeAttribute(nodeB, 'y') };
                    const dist = Math.sqrt((newX - posB.x) ** 2 + (newY - posB.y) ** 2);
                    
                    if (dist < minDistance && dist > 0) {
                        // Push nodes apart
                        const pushForce = (minDistance - dist) * 0.5;
                        const dx = (newX - posB.x) / dist;
                        const dy = (newY - posB.y) / dist;
                        
                        newX += dx * pushForce;
                        newY += dy * pushForce;
                        
                        // Reduce velocity to prevent bouncing
                        vx *= 0.8;
                        vy *= 0.8;
                    }
                });
                
                graph.setNodeAttribute(nodeA, 'x', newX);
                graph.setNodeAttribute(nodeA, 'y', newY);
                graph.setNodeAttribute(nodeA, 'vx', vx);
                graph.setNodeAttribute(nodeA, 'vy', vy);
            });
            
            sigma.refresh();
        }

        function setActiveLayout(layout) {
            document.querySelectorAll('.control-btn[id^="layout-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`layout-${layout}`).classList.add('active');
        }

        function applyClusteredForceLayout() {
            if (!graph || !sigma) return;
            
            console.log('Applying ForceAtlas2 cluster layout...');
            
            const nodes = graph.nodes();
            const actors = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'actor');
            const categories = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'category');
            const countries = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'country');
            
            // Group actors by category
            const actorsByCategory = {};
            actors.forEach(actor => {
                const actorData = graph.getNodeAttribute(actor, 'actorData');
                if (actorData && actorData.category) {
                    if (!actorsByCategory[actorData.category]) {
                        actorsByCategory[actorData.category] = [];
                    }
                    actorsByCategory[actorData.category].push(actor);
                }
            });
            
            // Initial cluster positioning for ForceAtlas2
            const categoriesArray = Object.keys(actorsByCategory);
            const clusterSpacing = 3000; // Large spacing for ForceAtlas2
            const cols = Math.max(2, Math.ceil(Math.sqrt(categoriesArray.length)));
            
            // Set initial cluster positions with large scale for ForceAtlas2
            categoriesArray.forEach((category, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const centerX = (col - (cols - 1) / 2) * clusterSpacing;
                const centerY = (row - (Math.ceil(categoriesArray.length / cols) - 1) / 2) * clusterSpacing;
                
                // Position category at cluster center
                const categoryNode = `category_${category}`;
                if (graph.hasNode(categoryNode)) {
                    graph.setNodeAttribute(categoryNode, 'x', centerX);
                    graph.setNodeAttribute(categoryNode, 'y', centerY);
                }
                
                // Position actors around category with good initial spacing
                const categoryActors = actorsByCategory[category];
                categoryActors.forEach((actor, i) => {
                    const angle = (i / categoryActors.length) * 2 * Math.PI;
                    const radius = 500 + Math.random() * 300;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    graph.setNodeAttribute(actor, 'x', x);
                    graph.setNodeAttribute(actor, 'y', y);
                });
            });
            
            // Position countries at outer ring
            const countryRadius = clusterSpacing * 3;
            countries.forEach((node, i) => {
                const angle = (i / countries.length) * 2 * Math.PI;
                const x = countryRadius * Math.cos(angle);
                const y = countryRadius * Math.sin(angle);
                graph.setNodeAttribute(node, 'x', x);
                graph.setNodeAttribute(node, 'y', y);
            });
            
            // Try to use ForceAtlas2, fallback to basic layout
            try {
                if (typeof forceAtlas2 !== 'undefined') {
                    console.log('Running ForceAtlas2 layout...');
                    
                    // Configure ForceAtlas2 for good clustering
                    forceAtlas2.assign(graph, {
                        iterations: 100,
                        settings: {
                            barnesHutOptimize: true,
                            barnesHutTheta: 0.5,
                            adjustSizes: false,
                            edgeWeightInfluence: 0.2,
                            scalingRatio: 15, // Strong repulsion for clear clusters
                            strongGravityMode: false,
                            gravity: 0.08, // Moderate gravity
                            slowDown: 1,
                            linLogMode: false
                        }
                    });
                    
                    console.log('ForceAtlas2 layout completed');
                } else {
                    console.warn('ForceAtlas2 not available, using fallback...');
                    // Keep the manual positioning as fallback
                }
            } catch (error) {
                console.warn('ForceAtlas2 failed:', error);
                // Keep the manual positioning as fallback
            }
            
            sigma.refresh();
        }


        function applyForceLayout() {
            if (!graph || !sigma) return;
            
            console.log('Applying force-directed layout...');
            
            const nodes = graph.nodes();
            const edges = graph.edges();
            
            // Initialize positions randomly if not set
            nodes.forEach(node => {
                if (!graph.hasNodeAttribute(node, 'x') || !graph.hasNodeAttribute(node, 'y')) {
                    graph.setNodeAttribute(node, 'x', (Math.random() - 0.5) * 1000);
                    graph.setNodeAttribute(node, 'y', (Math.random() - 0.5) * 1000);
                }
                // Initialize velocity
                graph.setNodeAttribute(node, 'vx', 0);
                graph.setNodeAttribute(node, 'vy', 0);
            });
            
            // Force-directed layout parameters
            const iterations = 150;
            const k = Math.sqrt(36000000 / nodes.length); // Extreme ideal distance for maximum cluster separation
            const temperature = 200;
            const cooling = 0.95;
            const repulsionStrength = 20000; // Balanced repulsion for smooth movement
            const attractionStrength = 0.15; // Further reduced attraction to allow more spread
            
            let temp = temperature;
            
            // Run force simulation
            for (let iter = 0; iter < iterations; iter++) {
                // Reset forces
                nodes.forEach(node => {
                    graph.setNodeAttribute(node, 'fx', 0);
                    graph.setNodeAttribute(node, 'fy', 0);
                });
                
                // Repulsive forces between all nodes
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const node1 = nodes[i];
                        const node2 = nodes[j];
                        
                        const x1 = graph.getNodeAttribute(node1, 'x');
                        const y1 = graph.getNodeAttribute(node1, 'y');
                        const x2 = graph.getNodeAttribute(node2, 'x');
                        const y2 = graph.getNodeAttribute(node2, 'y');
                        
                        const dx = x1 - x2;
                        const dy = y1 - y2;
                        const distance = Math.sqrt(dx * dx + dy * dy) || 0.01;
                        
                        // Calculate minimum distance based on node sizes - strong overlap prevention
                        const node1Size = graph.getNodeAttribute(node1, 'size') || 15;
                        const node2Size = graph.getNodeAttribute(node2, 'size') || 15;
                        const minDistance = (node1Size + node2Size) * 4; // Much larger buffer to prevent overlap
                        
                        if (distance < Math.max(k * 1.5, minDistance)) { // Focused on overlap prevention
                            let force = repulsionStrength / (distance * distance);
                            
                            // Gradual increase in repulsion as nodes get closer
                            if (distance < minDistance) {
                                const overlapRatio = (minDistance - distance) / minDistance;
                                force *= (1 + overlapRatio * 4); // Smooth scaling from 1x to 5x
                            }
                            
                            // Smooth emergency overlap prevention
                            if (distance < (node1Size + node2Size) * 1.1) {
                                force *= 3; // Moderate boost for actual overlap
                            }
                            
                            const fx = (dx / distance) * force;
                            const fy = (dy / distance) * force;
                            
                            graph.setNodeAttribute(node1, 'fx', graph.getNodeAttribute(node1, 'fx') + fx);
                            graph.setNodeAttribute(node1, 'fy', graph.getNodeAttribute(node1, 'fy') + fy);
                            graph.setNodeAttribute(node2, 'fx', graph.getNodeAttribute(node2, 'fx') - fx);
                            graph.setNodeAttribute(node2, 'fy', graph.getNodeAttribute(node2, 'fy') - fy);
                        }
                    }
                }
                
                // Attractive forces for connected nodes
                edges.forEach(edge => {
                    const source = graph.source(edge);
                    const target = graph.target(edge);
                    
                    const x1 = graph.getNodeAttribute(source, 'x');
                    const y1 = graph.getNodeAttribute(source, 'y');
                    const x2 = graph.getNodeAttribute(target, 'x');
                    const y2 = graph.getNodeAttribute(target, 'y');
                    
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 0.01;
                    
                    const force = attractionStrength * (distance - k);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    graph.setNodeAttribute(source, 'fx', graph.getNodeAttribute(source, 'fx') + fx);
                    graph.setNodeAttribute(source, 'fy', graph.getNodeAttribute(source, 'fy') + fy);
                    graph.setNodeAttribute(target, 'fx', graph.getNodeAttribute(target, 'fx') - fx);
                    graph.setNodeAttribute(target, 'fy', graph.getNodeAttribute(target, 'fy') - fy);
                });
                
                // Update positions based on forces
                nodes.forEach(node => {
                    const fx = graph.getNodeAttribute(node, 'fx');
                    const fy = graph.getNodeAttribute(node, 'fy');
                    
                    let vx = graph.getNodeAttribute(node, 'vx') + fx * 0.1;
                    let vy = graph.getNodeAttribute(node, 'vy') + fy * 0.1;
                    
                    // Apply damping
                    vx *= 0.9;
                    vy *= 0.9;
                    
                    // Limit velocity by temperature
                    const velocity = Math.sqrt(vx * vx + vy * vy);
                    if (velocity > temp) {
                        vx = (vx / velocity) * temp;
                        vy = (vy / velocity) * temp;
                    }
                    
                    // Update position
                    const x = graph.getNodeAttribute(node, 'x') + vx;
                    const y = graph.getNodeAttribute(node, 'y') + vy;
                    
                    graph.setNodeAttribute(node, 'x', x);
                    graph.setNodeAttribute(node, 'y', y);
                    graph.setNodeAttribute(node, 'vx', vx);
                    graph.setNodeAttribute(node, 'vy', vy);
                });
                
                // Cool down
                temp *= cooling;
                
                // Update display every 10 iterations
                if (iter % 10 === 0) {
                    sigma.refresh();
                }
            }
            
            // Clean up temporary attributes
            nodes.forEach(node => {
                graph.removeNodeAttribute(node, 'fx');
                graph.removeNodeAttribute(node, 'fy');
                graph.removeNodeAttribute(node, 'vx');
                graph.removeNodeAttribute(node, 'vy');
            });
            
            sigma.refresh();
        }

        function applyCircularLayout() {
            if (!graph || !sigma) return;
            
            const nodes = graph.nodes();
            const center = { x: 0, y: 0 };
            const radius = 800; // Much larger radius for better spacing
            
            nodes.forEach((node, i) => {
                const angle = (2 * Math.PI * i) / nodes.length;
                graph.setNodeAttribute(node, 'x', center.x + radius * Math.cos(angle));
                graph.setNodeAttribute(node, 'y', center.y + radius * Math.sin(angle));
            });
            
            sigma.refresh();
        }

        function applyInitialSpacedLayout() {
            if (!graph || !sigma) return;
            
            console.log('Applying organic cluster layout with generous spacing...');
            
            const nodes = graph.nodes();
            
            // Group nodes by type
            const countries = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'country');
            const categories = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'category');
            const actors = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'actor');
            
            // Create category-based clusters
            const actorsByCategory = {};
            actors.forEach(actor => {
                const actorData = graph.getNodeAttribute(actor, 'actorData');
                if (actorData && actorData.category) {
                    if (!actorsByCategory[actorData.category]) {
                        actorsByCategory[actorData.category] = [];
                    }
                    actorsByCategory[actorData.category].push(actor);
                }
            });
            
            // Position categories in organic scattered layout with massive spacing
            const categoriesArray = Object.keys(actorsByCategory);
            const clusterSpacing = 2200; // Massive distance between clusters
            
            // Use organic positioning - not rigid grid
            const clusterPositions = [
                { x: -clusterSpacing, y: -clusterSpacing * 0.7 },    // Top left
                { x: clusterSpacing, y: -clusterSpacing * 0.8 },     // Top right  
                { x: -clusterSpacing * 1.3, y: clusterSpacing * 0.5 }, // Mid left
                { x: clusterSpacing * 1.2, y: clusterSpacing * 0.6 },  // Mid right
                { x: 0, y: clusterSpacing * 1.1 },                   // Bottom center
                { x: -clusterSpacing * 0.6, y: clusterSpacing * 1.5 }, // Bottom left
            ];
            
            categoriesArray.forEach((category, index) => {
                // Use predefined positions or create organic scattered positions
                let centerX, centerY;
                if (index < clusterPositions.length) {
                    centerX = clusterPositions[index].x;
                    centerY = clusterPositions[index].y;
                } else {
                    // For additional categories, use organic scatter
                    const angle = (index * 2.4) % (2 * Math.PI); // Irregular spacing
                    const radius = clusterSpacing * (1.2 + Math.sin(index) * 0.3); // Varied distances
                    centerX = radius * Math.cos(angle);
                    centerY = radius * Math.sin(angle);
                }
                
                // Position the category node at cluster center
                const categoryNode = `category_${category}`;
                if (graph.hasNode(categoryNode)) {
                    graph.setNodeAttribute(categoryNode, 'x', centerX);
                    graph.setNodeAttribute(categoryNode, 'y', centerY);
                }
                
                // Position actors in organic cluster around category (not in rigid grid)
                const categoryActors = actorsByCategory[category];
                const clusterRadius = Math.max(300, Math.sqrt(categoryActors.length) * 120); // Larger dynamic cluster size
                
                // Track occupied positions to prevent overlap
                const occupiedPositions = [];
                const minDistance = 100; // Minimum distance between nodes
                
                categoryActors.forEach((actor, i) => {
                    let validPosition = false;
                    let attempts = 0;
                    let offsetX, offsetY;
                    
                    while (!validPosition && attempts < 50) {
                        // Create organic scatter around category center
                        const angle = (i / categoryActors.length) * 2 * Math.PI + Math.sin(i + attempts) * 0.8;
                        const distance = clusterRadius * (0.6 + (Math.sin(i + attempts) + 1) / 2 * 0.4);
                        offsetX = distance * Math.cos(angle);
                        offsetY = distance * Math.sin(angle);
                        
                        const newX = centerX + offsetX;
                        const newY = centerY + offsetY;
                        
                        // Check for overlap with existing positions
                        validPosition = true;
                        for (const pos of occupiedPositions) {
                            const dist = Math.sqrt((newX - pos.x) ** 2 + (newY - pos.y) ** 2);
                            if (dist < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        attempts++;
                        
                        // If no valid position found, expand the search radius
                        if (!validPosition && attempts % 10 === 0) {
                            clusterRadius *= 1.1;
                        }
                    }
                    
                    // Store the position to avoid future overlaps
                    occupiedPositions.push({ x: centerX + offsetX, y: centerY + offsetY });
                    
                    graph.setNodeAttribute(actor, 'x', centerX + offsetX);
                    graph.setNodeAttribute(actor, 'y', centerY + offsetY);
                });
            });
            
            // Position countries in organic scatter at the top
            const countrySpacing = 450; // Much more space between countries
            const countryOffsetY = -clusterSpacing * 1.8; // Even higher up
            
            // Track country positions to prevent overlap
            const countryPositions = [];
            const countryMinDistance = 150; // Minimum distance between countries
            
            countries.forEach((node, i) => {
                let validPosition = false;
                let attempts = 0;
                let x, y;
                
                while (!validPosition && attempts < 30) {
                    // Organic horizontal scatter for countries
                    const spread = (countries.length - 1) * countrySpacing;
                    const baseX = (i * countrySpacing) - spread / 2;
                    const variation = Math.sin(i + attempts) * 200; // Add variation based on attempts
                    x = baseX + variation;
                    y = countryOffsetY + Math.sin(i + attempts) * 200; // More vertical variation
                    
                    // Check for overlap with existing country positions
                    validPosition = true;
                    for (const pos of countryPositions) {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                        if (dist < countryMinDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    attempts++;
                }
                
                // Store the position to avoid future overlaps
                countryPositions.push({ x: x, y: y });
                
                graph.setNodeAttribute(node, 'x', x);
                graph.setNodeAttribute(node, 'y', y);
            });
            
            console.log('Organic cluster layout applied - natural spacing, no rigid patterns');
            sigma.refresh();
        }

        function startForceAtlas2Layout() {
            if (!graph || !sigma) return;
            
            console.log('Starting physics-based ForceAtlas2 layout...');
            
            try {
                // Check if ForceAtlas2 is available
                if (typeof forceAtlas2 === 'undefined') {
                    console.warn('ForceAtlas2 not available, using fallback physics layout');
                    applyPhysicsLayout();
                    return;
                }
                
                // Enhanced ForceAtlas2 configuration for maximum readable spacing
                const fa2Config = {
                    iterations: 500,
                    settings: {
                        barnesHutOptimize: true,
                        barnesHutTheta: 0.3,
                        adjustSizes: true,
                        edgeWeightInfluence: 0.5,
                        scalingRatio: 50,
                        strongGravityMode: false,
                        gravity: 0.005,
                        slowDown: 1.2,
                        linLogMode: false,
                        outboundAttractionDistribution: true,
                        jitterTolerance: 0.02
                    }
                };
                
                // Initialize with maximum spread for readability
                graph.forEachNode((node) => {
                    const nodeType = graph.getNodeAttribute(node, 'nodeType');
                    
                    if (nodeType === 'country') {
                        // Countries spread very widely horizontally at top
                        graph.setNodeAttribute(node, 'x', (Math.random() - 0.5) * 6000);
                        graph.setNodeAttribute(node, 'y', -2000 + (Math.random() - 0.5) * 600);
                    } else if (nodeType === 'category') {
                        // Categories distributed in very expanded center area
                        graph.setNodeAttribute(node, 'x', (Math.random() - 0.5) * 4000);
                        graph.setNodeAttribute(node, 'y', (Math.random() - 0.5) * 2000);
                    } else {
                        // Actors scattered very widely for maximum readability
                        graph.setNodeAttribute(node, 'x', (Math.random() - 0.5) * 5000);
                        graph.setNodeAttribute(node, 'y', (Math.random() - 0.5) * 4000);
                    }
                });
                
                // Run ForceAtlas2 with physics simulation
                forceAtlas2.assign(graph, fa2Config);
                
                console.log('Physics-based ForceAtlas2 layout completed');
                sigma.refresh();
                
            } catch (error) {
                console.warn('ForceAtlas2 failed, falling back to physics layout:', error);
                applyPhysicsLayout();
            }
        }

        function applyPhysicsLayout() {
            if (!graph || !sigma) return;
            
            console.log('Applying physics-based layout simulation...');
            
            const nodes = graph.nodes();
            const actors = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'actor');
            const categories = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'category');
            const countries = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'country');
            
            // Physics simulation parameters for maximum readable spacing
            const springLength = 500;
            const springStiffness = 0.02;
            const repulsionStrength = 15000;
            const damping = 0.9;
            const iterations = 250;
            
            // Initialize velocities
            const velocities = new Map();
            nodes.forEach(node => {
                velocities.set(node, { vx: 0, vy: 0 });
            });
            
            // Initialize with maximum spread for readability
            nodes.forEach(node => {
                const nodeType = graph.getNodeAttribute(node, 'nodeType');
                if (nodeType === 'country') {
                    graph.setNodeAttribute(node, 'x', (Math.random() - 0.5) * 6000);
                    graph.setNodeAttribute(node, 'y', -1800 + (Math.random() - 0.5) * 600);
                } else if (nodeType === 'category') {
                    graph.setNodeAttribute(node, 'x', (Math.random() - 0.5) * 4000);
                    graph.setNodeAttribute(node, 'y', (Math.random() - 0.5) * 2000);
                } else {
                    graph.setNodeAttribute(node, 'x', (Math.random() - 0.5) * 5000);
                    graph.setNodeAttribute(node, 'y', (Math.random() - 0.5) * 4000);
                }
            });
            
            // Run physics simulation
            for (let i = 0; i < iterations; i++) {
                // Calculate forces
                nodes.forEach(nodeA => {
                    const posA = { x: graph.getNodeAttribute(nodeA, 'x'), y: graph.getNodeAttribute(nodeA, 'y') };
                    const vel = velocities.get(nodeA);
                    let fx = 0, fy = 0;
                    
                    // Repulsion from all other nodes
                    nodes.forEach(nodeB => {
                        if (nodeA === nodeB) return;
                        const posB = { x: graph.getNodeAttribute(nodeB, 'x'), y: graph.getNodeAttribute(nodeB, 'y') };
                        const dx = posA.x - posB.x;
                        const dy = posA.y - posB.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) + 1;
                        const force = repulsionStrength / (distance * distance);
                        fx += (dx / distance) * force;
                        fy += (dy / distance) * force;
                    });
                    
                    // Attraction from connected nodes
                    graph.forEachNeighbor(nodeA, (neighbor) => {
                        const posB = { x: graph.getNodeAttribute(neighbor, 'x'), y: graph.getNodeAttribute(neighbor, 'y') };
                        const dx = posB.x - posA.x;
                        const dy = posB.y - posA.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const displacement = distance - springLength;
                        const force = springStiffness * displacement;
                        fx += (dx / distance) * force;
                        fy += (dy / distance) * force;
                    });
                    
                    // Update velocity and position
                    vel.vx = (vel.vx + fx) * damping;
                    vel.vy = (vel.vy + fy) * damping;
                    
                    graph.setNodeAttribute(nodeA, 'x', posA.x + vel.vx);
                    graph.setNodeAttribute(nodeA, 'y', posA.y + vel.vy);
                });
            }
            
            console.log('Physics-based layout simulation completed');
            sigma.refresh();
        }

        function applySimpleClusterLayout() {
            if (!graph || !sigma) return;
            
            console.log('Applying simple cluster layout...');
            
            const nodes = graph.nodes();
            const actors = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'actor');
            const categories = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'category');
            const countries = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'country');
            
            // Group actors by category
            const actorsByCategory = {};
            actors.forEach(actor => {
                const actorData = graph.getNodeAttribute(actor, 'actorData');
                if (actorData && actorData.category) {
                    if (!actorsByCategory[actorData.category]) {
                        actorsByCategory[actorData.category] = [];
                    }
                    actorsByCategory[actorData.category].push(actor);
                }
            });
            
            // Simple cluster positions in a grid
            const categoriesArray = Object.keys(actorsByCategory);
            const clusterSpacing = 1000;
            const cols = Math.ceil(Math.sqrt(categoriesArray.length));
            
            categoriesArray.forEach((category, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const centerX = (col - (cols - 1) / 2) * clusterSpacing;
                const centerY = (row - (Math.ceil(categoriesArray.length / cols) - 1) / 2) * clusterSpacing;
                
                // Position category at center
                const categoryNode = `category_${category}`;
                if (graph.hasNode(categoryNode)) {
                    graph.setNodeAttribute(categoryNode, 'x', centerX);
                    graph.setNodeAttribute(categoryNode, 'y', centerY);
                }
                
                // Position actors around category in a simple circle
                const categoryActors = actorsByCategory[category];
                const radius = Math.max(200, categoryActors.length * 25);
                
                categoryActors.forEach((actor, i) => {
                    const angle = (2 * Math.PI * i) / categoryActors.length;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    graph.setNodeAttribute(actor, 'x', x);
                    graph.setNodeAttribute(actor, 'y', y);
                });
            });
            
            // Position countries in a line at the top
            const countryY = -800;
            const countrySpacing = 200;
            countries.forEach((node, i) => {
                const x = (i - (countries.length - 1) / 2) * countrySpacing;
                graph.setNodeAttribute(node, 'x', x);
                graph.setNodeAttribute(node, 'y', countryY);
            });
            
            sigma.refresh();
        }

        function applyClusteredCircularLayout() {
            if (!graph || !sigma) return;
            
            console.log('Applying clustered circular layout...');
            
            const nodes = graph.nodes();
            
            // Group nodes by type
            const countries = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'country');
            const categories = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'category');
            const actors = nodes.filter(node => graph.getNodeAttribute(node, 'nodeType') === 'actor');
            
            // Define cluster centers with large separation
            const clusterCenters = {
                countries: { x: -1500, y: 0 },
                categories: { x: 1500, y: 0 },
                actors: { x: 0, y: 1200 }
            };
            
            // Position countries in a circle
            const countryRadius = 600;
            countries.forEach((node, i) => {
                const angle = (2 * Math.PI * i) / countries.length;
                const x = clusterCenters.countries.x + countryRadius * Math.cos(angle);
                const y = clusterCenters.countries.y + countryRadius * Math.sin(angle);
                graph.setNodeAttribute(node, 'x', x);
                graph.setNodeAttribute(node, 'y', y);
            });
            
            // Position categories in a circle
            const categoryRadius = 400;
            categories.forEach((node, i) => {
                const angle = (2 * Math.PI * i) / categories.length;
                const x = clusterCenters.categories.x + categoryRadius * Math.cos(angle);
                const y = clusterCenters.categories.y + categoryRadius * Math.sin(angle);
                graph.setNodeAttribute(node, 'x', x);
                graph.setNodeAttribute(node, 'y', y);
            });
            
            // Position actors in clusters around their categories
            const actorsByCategory = {};
            actors.forEach(actor => {
                const actorData = graph.getNodeAttribute(actor, 'actorData');
                if (actorData && actorData.category) {
                    if (!actorsByCategory[actorData.category]) {
                        actorsByCategory[actorData.category] = [];
                    }
                    actorsByCategory[actorData.category].push(actor);
                }
            });
            
            // Create actor clusters with good spacing
            let actorClusterIndex = 0;
            const actorClustersPerRow = 4;
            const actorClusterSpacing = 600;
            
            Object.keys(actorsByCategory).forEach((category, categoryIndex) => {
                const categoryActors = actorsByCategory[category];
                
                // Calculate cluster position
                const clusterX = clusterCenters.actors.x + (actorClusterIndex % actorClustersPerRow - 1.5) * actorClusterSpacing;
                const clusterY = clusterCenters.actors.y + Math.floor(actorClusterIndex / actorClustersPerRow) * actorClusterSpacing;
                
                // Position actors in a small circle around cluster center
                const actorRadius = Math.min(200, 50 + categoryActors.length * 8); // Adaptive radius
                categoryActors.forEach((actor, i) => {
                    const angle = (2 * Math.PI * i) / categoryActors.length;
                    const x = clusterX + actorRadius * Math.cos(angle);
                    const y = clusterY + actorRadius * Math.sin(angle);
                    graph.setNodeAttribute(actor, 'x', x);
                    graph.setNodeAttribute(actor, 'y', y);
                });
                
                actorClusterIndex++;
            });
            
            sigma.refresh();
        }

        function applyHierarchicalLayout() {
            if (!graph || !sigma) return;
            
            const countries = graph.nodes().filter(node => graph.getNodeAttribute(node, 'nodeType') === 'country');
            const categories = graph.nodes().filter(node => graph.getNodeAttribute(node, 'nodeType') === 'category');
            const actors = graph.nodes().filter(node => graph.getNodeAttribute(node, 'nodeType') === 'actor');
            
            // Position countries at top with more spacing
            countries.forEach((node, i) => {
                graph.setNodeAttribute(node, 'x', (i + 1) * (1600 / (countries.length + 1)) - 800);
                graph.setNodeAttribute(node, 'y', -400);
            });
            
            // Position categories in middle with more spacing
            categories.forEach((node, i) => {
                graph.setNodeAttribute(node, 'x', (i + 1) * (1600 / (categories.length + 1)) - 800);
                graph.setNodeAttribute(node, 'y', 0);
            });
            
            // Position actors at bottom with more spacing
            actors.forEach((node, i) => {
                graph.setNodeAttribute(node, 'x', (i + 1) * (3200 / (actors.length + 1)) - 1600);
                graph.setNodeAttribute(node, 'y', 400);
            });
            
            sigma.refresh();
        }

        function selectGraphActor(actor) {
            // Update selected node
            selectedNode = `actor_${actor.name}`;
            
            // Refresh sigma to update highlighting
            if (sigma) {
                sigma.refresh();
            }
            
            displayActorDetails(actor);
        }

        function selectCountry(countryNodeId) {
            // Extract country name from node ID
            const countryName = countryNodeId.replace('country_', '');
            
            // Update selected node
            selectedNode = countryNodeId;
            
            // Find all threat actors from this country
            const connectedActors = [];
            graph.forEachNeighbor(countryNodeId, (neighborId) => {
                const neighborData = graph.getNodeAttributes(neighborId);
                if (neighborData.nodeType === 'actor' && neighborData.actorData) {
                    connectedActors.push(neighborData.actorData);
                }
            });
            
            // Display country details
            displayCountryDetails(countryName, connectedActors);
            
            // Refresh sigma to update highlighting
            if (sigma) {
                sigma.refresh();
            }
        }

        function selectCategory(categoryNodeId) {
            // Extract category name from node ID
            const categoryName = categoryNodeId.replace('category_', '');
            
            // Update selected node
            selectedNode = categoryNodeId;
            
            // Find all threat actors in this category
            const connectedActors = [];
            graph.forEachNeighbor(categoryNodeId, (neighborId) => {
                const neighborData = graph.getNodeAttributes(neighborId);
                if (neighborData.nodeType === 'actor' && neighborData.actorData) {
                    connectedActors.push(neighborData.actorData);
                }
            });
            
            // Display category details
            displayCategoryDetails(categoryName, connectedActors);
            
            // Refresh sigma to update highlighting
            if (sigma) {
                sigma.refresh();
            }
        }

        function getFilteredActors() {
            const searchTerm = document.getElementById('search')?.value.toLowerCase() || '';
            const selectedCategory = document.getElementById('categoryFilter')?.value || '';
            const selectedFamily = document.getElementById('familyFilter')?.value || '';
            const selectedCountries = Array.from(document.querySelectorAll('#countryFilters input[type="checkbox"]:checked') || []).map(cb => cb.value);
            const selectedCategories = Array.from(document.querySelectorAll('#categoryFilters input[type="checkbox"]:checked') || []).map(cb => cb.value);

            return threatActorsData.threat_actors.filter(actor => {
                // Search filter - search in actor name, other names, country, and category
                if (searchTerm) {
                    const matchesActorName = actor.name.toLowerCase().includes(searchTerm);
                    const matchesOtherNames = actor.other_names && actor.other_names.some(name => name.toLowerCase().includes(searchTerm));
                    const matchesCountry = actor.origin.toLowerCase().includes(searchTerm);
                    const matchesCategory = actor.category.toLowerCase().includes(searchTerm);
                    const matchesFamily = actor.family.toLowerCase().includes(searchTerm);
                    
                    if (!matchesActorName && !matchesOtherNames && !matchesCountry && !matchesCategory && !matchesFamily) {
                        return false;
                    }
                }

                // Category dropdown filter (takes precedence if set)
                if (selectedCategory && actor.category !== selectedCategory) {
                    return false;
                }

                // Category checkbox filter (only if dropdown is not set)
                if (!selectedCategory && selectedCategories.length > 0 && !selectedCategories.includes(actor.category)) {
                    return false;
                }

                // Family filter
                if (selectedFamily && actor.family !== selectedFamily) {
                    return false;
                }

                // Country filter
                if (selectedCountries.length > 0 && !selectedCountries.includes(actor.origin)) {
                    return false;
                }

                return true;
            });
        }

        function renderByCountry() {
            const container = document.getElementById('matrix-container');
            const filteredActors = getFilteredActors();
            
            // Group actors by country
            const actorsByCountry = {};
            filteredActors.forEach(actor => {
                const country = actor.origin;
                if (!actorsByCountry[country]) {
                    actorsByCountry[country] = [];
                }
                actorsByCountry[country].push(actor);
            });

            // Clear container
            container.innerHTML = '';

            // Sort countries by actor count
            const sortedCountries = Object.keys(actorsByCountry).sort((a, b) => 
                actorsByCountry[b].length - actorsByCountry[a].length
            );

            sortedCountries.forEach(country => {
                const section = createCountrySection(country, actorsByCountry[country]);
                container.appendChild(section);
            });
        }

        function renderByCategory() {
            const container = document.getElementById('matrix-container');
            const filteredActors = getFilteredActors();
            
            // Group actors by category
            const actorsByCategory = {};
            filteredActors.forEach(actor => {
                const category = actor.category;
                if (!actorsByCategory[category]) {
                    actorsByCategory[category] = [];
                }
                actorsByCategory[category].push(actor);
            });

            // Clear container
            container.innerHTML = '';

            // Sort categories by actor count
            const sortedCategories = Object.keys(actorsByCategory).sort((a, b) => 
                actorsByCategory[b].length - actorsByCategory[a].length
            );

            sortedCategories.forEach(category => {
                const section = createCategorySection(category, actorsByCategory[category]);
                container.appendChild(section);
            });
        }

        function renderByFamily() {
            const container = document.getElementById('matrix-container');
            const filteredActors = getFilteredActors();
            
            // Group actors by family
            const actorsByFamily = {};
            filteredActors.forEach(actor => {
                const family = actor.family;
                if (!actorsByFamily[family]) {
                    actorsByFamily[family] = [];
                }
                actorsByFamily[family].push(actor);
            });

            // Clear container
            container.innerHTML = '';

            // Sort families by actor count
            const sortedFamilies = Object.keys(actorsByFamily).sort((a, b) => 
                actorsByFamily[b].length - actorsByFamily[a].length
            );

            sortedFamilies.forEach(family => {
                const section = createFamilySection(family, actorsByFamily[family]);
                container.appendChild(section);
            });
        }

        function createCountrySection(country, actors) {
            const section = document.createElement('div');
            section.className = 'country-section';

            const flag = countryFlags[country] || '';
            
            section.innerHTML = `
                <div class="country-header">
                    <span class="country-flag">${flag}</span>
                    <span>${country}</span>
                    <span style="margin-left: auto; opacity: 0.8;">${actors.length} actors</span>
                </div>
                <div class="actor-grid">
                    ${actors.map(actor => createActorCard(actor)).join('')}
                </div>
            `;

            return section;
        }

        function createCategorySection(category, actors) {
            const section = document.createElement('div');
            section.className = 'country-section';

            const categoryIcon = categoryIcons[category] || '<i class="fas fa-question"></i>';
            const categoryColor = categoryColors[category] || '#666';
            
            section.innerHTML = `
                <div class="country-header" style="background: linear-gradient(90deg, ${categoryColor}, ${categoryColor}dd);">
                    <span>${categoryIcon}</span>
                    <span>${category}</span>
                    <span style="margin-left: auto; opacity: 0.8;">${actors.length} actors</span>
                </div>
                <div class="actor-grid">
                    ${actors.map(actor => createActorCard(actor)).join('')}
                </div>
            `;

            return section;
        }

        function createFamilySection(family, actors) {
            const section = document.createElement('div');
            section.className = 'country-section';

            const familyIcon = familyIcons[family] || '<i class="fas fa-users"></i>';
            
            section.innerHTML = `
                <div class="country-header" style="background: linear-gradient(90deg, #7c3aed, #6d28d9);">
                    <span>${familyIcon}</span>
                    <span>${family} Family</span>
                    <span style="margin-left: auto; opacity: 0.8;">${actors.length} actors</span>
                </div>
                <div class="actor-grid">
                    ${actors.map(actor => createActorCard(actor)).join('')}
                </div>
            `;

            return section;
        }

        function createActorCard(actor) {
            const categoryColor = categoryColors[actor.category] || '#666';
            const categoryIcon = categoryIcons[actor.category] || '<i class="fas fa-question"></i>';
            
            const aliases = actor.other_names && actor.other_names.length > 0 ? 
                actor.other_names.slice(0, 4).map(name => `<span class="alias-chip">${name}</span>`).join('') +
                (actor.other_names.length > 4 ? `<span class="alias-chip">+${actor.other_names.length - 4}</span>` : '')
                : '<span class="alias-chip">No aliases</span>';

            return `
                <div class="actor-card" style="--category-color: ${categoryColor}" onclick="selectActor('${actor.name.replace(/'/g, "\\'")}')">
                    <div class="actor-header">
                        <div class="actor-category-icon">
                            ${categoryIcon}
                        </div>
                        <div class="actor-info">
                            <div class="actor-name">${actor.name}</div>
                            <div class="actor-family">${actor.family}  ${actor.category}</div>
                        </div>
                    </div>
                    <div class="actor-aliases">
                        <div class="actor-aliases-label">Aliases</div>
                        <div class="alias-list">${aliases}</div>
                    </div>
                </div>
            `;
        }

        function selectActor(actorName) {
            // Remove previous selection
            document.querySelectorAll('.actor-card').forEach(card => card.classList.remove('selected'));
            
            // Find and select the clicked actor
            const actor = threatActorsData.threat_actors.find(a => a.name === actorName);
            if (actor) {
                event.target.closest('.actor-card').classList.add('selected');
                displayActorDetails(actor);
            }
        }

        function displayCountryDetails(countryName, connectedActors) {
            const detailsContainer = document.getElementById('actorDetails');
            const countryFlag = countryFlags[countryName] || '';
            
            // Sort actors by category for better organization
            connectedActors.sort((a, b) => a.category.localeCompare(b.category));
            
            detailsContainer.innerHTML = `
                <div class="actor-profile">
                    <!-- Country Header -->
                    <div class="primary-header">
                        <div class="actor-name-section">
                            <div class="threat-icon">${countryFlag}</div>
                            <div class="primary-name">${countryName}</div>
                        </div>
                        <div class="primary-subtitle">Country Overview  ${connectedActors.length} Threat Actors</div>
                    </div>

                    <!-- Connected Threat Actors -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-users"></i> Threat Actors from ${countryName}</h3>
                        <div class="section-content">
                            ${connectedActors.length > 0 ? `
                                <div class="threat-actors-list">
                                    ${connectedActors.map(actor => `
                                        <div class="actor-list-item" onclick="selectActorFromList('${actor.name.replace(/'/g, "\\'")}')">
                                            <div class="actor-item-header">
                                                <div class="actor-item-icon">
                                                    ${categoryIcons[actor.category] || '<i class="fas fa-user-secret"></i>'}
                                                </div>
                                                <div class="actor-item-info">
                                                    <div class="actor-item-name">${actor.name}</div>
                                                    <div class="actor-item-details">${actor.family}  ${actor.category}</div>
                                                </div>
                                            </div>
                                            ${actor.other_names && actor.other_names.length > 0 ? `
                                                <div class="actor-item-aliases">
                                                    ${actor.other_names.slice(0, 3).map(name => `<span class="alias-chip-small">${name}</span>`).join('')}
                                                    ${actor.other_names.length > 3 ? `<span class="alias-chip-small">+${actor.other_names.length - 3}</span>` : ''}
                                                </div>
                                            ` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '<div class="no-data">No threat actors found from this country</div>'}
                        </div>
                    </div>

                    <!-- Statistics -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-chart-bar"></i> Statistics</h3>
                        <div class="section-content">
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-label">Total Actors:</span>
                                    <span class="stat-value">${connectedActors.length}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Categories:</span>
                                    <span class="stat-value">${[...new Set(connectedActors.map(a => a.category))].length}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Families:</span>
                                    <span class="stat-value">${[...new Set(connectedActors.map(a => a.family))].length}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function displayCategoryDetails(categoryName, connectedActors) {
            const detailsContainer = document.getElementById('actorDetails');
            const categoryIcon = categoryIcons[categoryName] || '<i class="fas fa-users"></i>';
            const categoryColor = categoryColors[categoryName] || '#7c3aed';
            const categoryDescription = categoryDetailedDescriptions[categoryName] || 'No description available';
            
            // Sort actors by name
            connectedActors.sort((a, b) => a.name.localeCompare(b.name));
            
            detailsContainer.innerHTML = `
                <div class="actor-profile">
                    <!-- Category Header -->
                    <div class="primary-header">
                        <div class="actor-name-section">
                            <div class="threat-icon" style="color: ${categoryColor}">${categoryIcon}</div>
                            <div class="primary-name">${categoryName}</div>
                        </div>
                        <div class="primary-subtitle">Category Overview  ${connectedActors.length} Threat Actors</div>
                    </div>

                    <!-- Category Description -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-info-circle"></i> Description</h3>
                        <div class="section-content">
                            <p style="color: #c9d1d9; line-height: 1.6; margin: 0;">${categoryDescription}</p>
                        </div>
                    </div>

                    <!-- Connected Threat Actors -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-users"></i> Threat Actors in ${categoryName}</h3>
                        <div class="section-content">
                            ${connectedActors.length > 0 ? `
                                <div class="threat-actors-list">
                                    ${connectedActors.map(actor => `
                                        <div class="actor-list-item" onclick="selectActorFromList('${actor.name.replace(/'/g, "\\'")}')">
                                            <div class="actor-item-header">
                                                <div class="actor-item-icon">
                                                    ${countryFlags[actor.origin] || ''}
                                                </div>
                                                <div class="actor-item-info">
                                                    <div class="actor-item-name">${actor.name}</div>
                                                    <div class="actor-item-details">${actor.family}  ${actor.origin}</div>
                                                </div>
                                            </div>
                                            ${actor.other_names && actor.other_names.length > 0 ? `
                                                <div class="actor-item-aliases">
                                                    ${actor.other_names.slice(0, 3).map(name => `<span class="alias-chip-small">${name}</span>`).join('')}
                                                    ${actor.other_names.length > 3 ? `<span class="alias-chip-small">+${actor.other_names.length - 3}</span>` : ''}
                                                </div>
                                            ` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '<div class="no-data">No threat actors found in this category</div>'}
                        </div>
                    </div>

                    <!-- Statistics -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-chart-bar"></i> Statistics</h3>
                        <div class="section-content">
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-label">Total Actors:</span>
                                    <span class="stat-value">${connectedActors.length}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Countries:</span>
                                    <span class="stat-value">${[...new Set(connectedActors.map(a => a.origin))].length}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Families:</span>
                                    <span class="stat-value">${[...new Set(connectedActors.map(a => a.family))].length}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function selectActorFromList(actorName) {
            // Find the actor data
            const actor = threatActorsData.threat_actors.find(a => a.name === actorName);
            if (actor) {
                selectGraphActor(actor);
            }
        }

        function displayActorDetails(actor) {
            const detailsContainer = document.getElementById('actorDetails');
            
            // Get flag and icons
            const countryFlag = countryFlags[actor.origin] || '';
            const categoryIcon = categoryIcons[actor.category] || '<i class="fas fa-user-secret"></i>';
            const familyIcon = familyIcons[actor.family] || '<i class="fas fa-users"></i>';
            
            // Generate mock MITRE ATT&CK techniques based on actor type and family
            const mockTechniques = generateMockTechniques(actor);
            
            // Generate description based on actor data
            const description = generateActorDescription(actor);
            
            detailsContainer.innerHTML = `
                <div class="actor-profile">
                    <!-- Primary Header Section -->
                    <div class="primary-header">
                        <div class="actor-name-section">
                            <div class="threat-icon">${categoryIcon}</div>
                            <div class="primary-name">${actor.name}</div>
                        </div>
                        <div class="primary-subtitle">${familyIcon} ${actor.family} Family  ${actor.category}</div>
                    </div>

                    <!-- Attribution Section -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-flag"></i> Attribution</h3>
                        <div class="section-content">
                            <div class="attribution-list">
                                <div class="attribution-row">
                                    <div class="attribution-icon">
                                        <i class="fas fa-map-marker-alt"></i>
                                    </div>
                                    <div class="attribution-content">
                                        <div class="attribution-label">Origin</div>
                                        <div class="attribution-value">${actor.origin}</div>
                                    </div>
                                </div>
                                
                                <div class="attribution-row">
                                    <div class="attribution-icon">
                                        <i class="fas fa-tag"></i>
                                    </div>
                                    <div class="attribution-content">
                                        <div class="attribution-label">Category</div>
                                        <div class="attribution-value">
                                            ${categoryIcon}
                                            ${actor.category}
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="attribution-row">
                                    <div class="attribution-icon">
                                        <i class="fas fa-sitemap"></i>
                                    </div>
                                    <div class="attribution-content">
                                        <div class="attribution-label">Family</div>
                                        <div class="attribution-value">
                                            ${familyIcon}
                                            ${actor.family}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Aliases Section -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-id-badge"></i> Known Aliases</h3>
                        <div class="section-content">
                            ${actor.other_names && actor.other_names.length > 0 ? `
                                <div class="aliases-container">
                                    ${actor.other_names.map(name => `<div class="alias-tag">${name}</div>`).join('')}
                                </div>
                            ` : '<div class="no-data">No known aliases reported</div>'}
                        </div>
                    </div>

                    <!-- Description Section -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-file-alt"></i> Background</h3>
                        <div class="section-content">
                            <p class="description-text">${description}</p>
                        </div>
                    </div>

                    <!-- Related Reports Section -->
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-newspaper"></i> Related Reports</h3>
                        <div class="section-content">
                            <div id="reports-container-${actor.name.replace(/\s+/g, '-')}" class="reports-container">
                                <div class="loading-reports">
                                    <i class="fas fa-spinner fa-spin"></i> Loading reports from Orkl...
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- MITRE ATT&CK TTPs Section - Commented out for now -->
                    <!--
                    <div class="profile-section">
                        <h3 class="section-title"><i class="fas fa-shield-alt"></i> MITRE ATT&CK TTPs</h3>
                        <div class="section-content">
                            <div class="mitre-techniques">
                                ${mockTechniques.map(technique => `
                                    <div class="technique-item tactic-${technique.tactic.toLowerCase().replace(/\s+/g, '-')}">
                                        <div class="technique-id">${technique.id}</div>
                                        <div class="technique-name">${technique.name}</div>
                                        <div class="technique-category">${technique.tactic}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    -->
                </div>
            `;
            
            // Fetch related reports from Orkl API
            fetchThreatActorReports(actor);
        }

        function generateActorDescription(actor) {
            const categoryDescriptions = {
                'Nation-state': `${actor.name} is a nation-state sponsored threat group attributed to ${actor.origin}. This ${actor.family} family actor conducts cyber espionage operations aligned with state interests and geopolitical objectives.`,
                'Financially motivated': `${actor.name} is a financially motivated cybercriminal group. This ${actor.family} family actor primarily focuses on monetary gain through various cybercrime activities including ransomware, banking fraud, and cryptocurrency theft.`,
                'Private sector offensive actor': `${actor.name} is a private sector offensive actor (PSOA) that develops and sells commercial cyber capabilities. This ${actor.family} family entity provides offensive cyber tools and services to various clients.`,
                'Influence operations': `${actor.name} conducts influence operations and information warfare campaigns. This ${actor.family} family actor focuses on manipulating public opinion and disrupting information environments.`,
                'Groups in development': `${actor.name} is a developing threat group currently under analysis. This ${actor.family} designation indicates emerging or evolving threat activity requiring further investigation.`
            };
            
            return categoryDescriptions[actor.category] || `${actor.name} is a threat actor attributed to ${actor.origin} operating within the ${actor.family} family classification.`;
        }

        function generateMockTechniques(actor) {
            // MITRE ATT&CK TTPs function - returning empty array for now
            return [];
        }

        // Orkl API integration with rate limiting
        const orklAPI = {
            baseURL: 'https://orkl.eu/api/v1',
            requestQueue: [],
            lastRequestTime: 0,
            requestCount: 0,
            rateLimitWindow: 30000, // 30 seconds
            maxRequestsPerWindow: 100,
            
            async makeRequest(url) {
                const now = Date.now();
                
                // Reset counter if window has passed
                if (now - this.lastRequestTime > this.rateLimitWindow) {
                    this.requestCount = 0;
                    this.lastRequestTime = now;
                }
                
                // Check rate limit
                if (this.requestCount >= this.maxRequestsPerWindow) {
                    const waitTime = this.rateLimitWindow - (now - this.lastRequestTime);
                    console.log(`Rate limit reached. Waiting ${waitTime}ms...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    this.requestCount = 0;
                    this.lastRequestTime = Date.now();
                }
                
                this.requestCount++;
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Orkl API request failed:', error);
                    throw error;
                }
            },
            
            async findThreatActorByName(name) {
                const url = `${this.baseURL}/ta/entries`;
                const data = await this.makeRequest(url);
                const actors = data.data || [];
                
                for (const actor of actors) {
                    if (actor.main_name.toLowerCase() === name.toLowerCase() || 
                        (actor.aliases && actor.aliases.some(alias => alias.toLowerCase() === name.toLowerCase()))) {
                        return actor;
                    }
                }
                return null;
            },
            
            async getThreatActorReports(actorId) {
                const url = `${this.baseURL}/ta/entry/${actorId}`;
                const data = await this.makeRequest(url);
                return data.data?.reports || [];
            }
        };

        async function fetchThreatActorReports(actor) {
            const containerId = `reports-container-${actor.name.replace(/\s+/g, '-')}`;
            const container = document.getElementById(containerId);
            
            if (!container) {
                console.error('Reports container not found:', containerId);
                return;
            }
            
            try {
                // Try to find the threat actor in Orkl using the main name
                let orklActor = await orklAPI.findThreatActorByName(actor.name);
                
                // If not found by main name, try aliases
                if (!orklActor && actor.other_names && actor.other_names.length > 0) {
                    for (const alias of actor.other_names) {
                        orklActor = await orklAPI.findThreatActorByName(alias);
                        if (orklActor) {
                            console.log(`Found threat actor by alias: ${alias}`);
                            break;
                        }
                    }
                }
                
                if (orklActor) {
                    console.log(`Found Orkl threat actor: ${orklActor.main_name} (ID: ${orklActor.id})`);
                    const reports = await orklAPI.getThreatActorReports(orklActor.id);
                    
                    if (reports && reports.length > 0) {
                        // Debug: log the first report to see its structure
                        console.log('Sample report structure:', reports[0]);
                        
                        // Sort reports by creation date (most recent first) and take only 5
                        const sortedReports = reports
                            .sort((a, b) => new Date(b.ts_creation_date || 0) - new Date(a.ts_creation_date || 0))
                            .slice(0, 5);
                        
                        // Create search URL for all reports related to this threat actor
                        const searchQuery = encodeURIComponent(actor.name);
                        const searchUrl = `https://orkl.eu/search?orkl_library%5BsortBy%5D=orkl_library%3Ats_creation_date%3Adesc&orkl_library%5Bquery%5D=${searchQuery}`;
                        
                        container.innerHTML = `
                            <div class="reports-list">
                                <div class="reports-header">
                                    <span class="reports-count">${reports.length} report${reports.length !== 1 ? 's' : ''} found (showing 5 most recent)</span>
                                </div>
                                ${sortedReports.map(report => {
                                    const reportUrl = `https://orkl.eu/libraryEntry/${report.id}`;
                                    
                                    return `
                                        <div class="report-item">
                                            <div class="report-title">
                                                <a href="${reportUrl}" target="_blank" title="Report ID: ${report.id}">
                                                    ${report.title || report.name || 'Untitled Report'}
                                                </a>
                                            </div>
                                            <div class="report-meta">
                                                <span class="report-id">ID: ${report.id}</span>
                                                ${report.ts_creation_date ? `<span class="report-date">${new Date(report.ts_creation_date).toLocaleDateString()}</span>` : ''}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                                <div class="reports-footer">
                                    <a href="${searchUrl}" target="_blank" class="view-all-reports-btn">
                                        <i class="fas fa-search"></i> View All Reports for ${actor.name}
                                    </a>
                                </div>
                            </div>
                        `;
                    } else {
                        container.innerHTML = `
                            <div class="no-reports">
                                <i class="fas fa-info-circle"></i>
                                No reports found for this threat actor in Orkl database.
                            </div>
                        `;
                    }
                } else {
                    container.innerHTML = `
                        <div class="no-reports">
                            <i class="fas fa-search"></i>
                            Threat actor not found in Orkl database.
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error fetching reports from Orkl:', error);
                container.innerHTML = `
                    <div class="error-reports">
                        <i class="fas fa-exclamation-triangle"></i>
                        Error loading reports: ${error.message}
                    </div>
                `;
            }
        }

        function populateFilters() {
            // Populate category filter dropdown
            const categorySelect = document.getElementById('categoryFilter');
            const categories = [...new Set(threatActorsData.threat_actors.map(actor => actor.category))];
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categorySelect.appendChild(option);
            });

            // Populate category checkboxes
            const categoryContainer = document.getElementById('categoryFilters');
            categories.forEach(category => {
                const categoryIcon = categoryIcons[category] || '<i class="fas fa-question"></i>';
                const checkboxItem = document.createElement('div');
                checkboxItem.className = 'checkbox-item';
                checkboxItem.innerHTML = `
                    <input type="checkbox" id="category_${category.replace(/\s+/g, '_')}" value="${category}" checked>
                    <label for="category_${category.replace(/\s+/g, '_')}">
                        <span class="category-icon-small">${categoryIcon}</span>
                        ${category}
                    </label>
                `;
                categoryContainer.appendChild(checkboxItem);
            });

            // Populate family filter
            const familySelect = document.getElementById('familyFilter');
            const families = [...new Set(threatActorsData.threat_actors.map(actor => actor.family))];
            families.forEach(family => {
                const option = document.createElement('option');
                option.value = family;
                option.textContent = family;
                familySelect.appendChild(option);
            });

            // Populate country filters
            const countryContainer = document.getElementById('countryFilters');
            const countries = [...new Set(threatActorsData.threat_actors.map(actor => actor.origin))].sort();
            countries.forEach(country => {
                const countryFlag = countryFlags[country] || '';
                const checkboxItem = document.createElement('div');
                checkboxItem.className = 'checkbox-item';
                checkboxItem.innerHTML = `
                    <input type="checkbox" id="country_${country.replace(/\s+/g, '_')}" value="${country}" checked>
                    <label for="country_${country.replace(/\s+/g, '_')}">
                        <span class="country-flag-small">${countryFlag}</span>
                        ${country}
                    </label>
                `;
                countryContainer.appendChild(checkboxItem);
            });

            // Add event listeners
            document.getElementById('search').addEventListener('input', applyFilters);
            document.getElementById('categoryFilter').addEventListener('change', applyFilters);
            document.getElementById('familyFilter').addEventListener('change', applyFilters);
            countryContainer.addEventListener('change', applyFilters);
            categoryContainer.addEventListener('change', applyFilters);
        }

        function applyFilters() {
            // Check which tab is active
            const activeTab = document.querySelector('.tab-btn.active').id;
            
            if (activeTab === 'tab-graph') {
                // Update graph view
                updateGraphFilters();
            } else if (activeTab === 'tab-cards') {
                // Update card view - check which card view is active
                const activeCardView = document.querySelector('.view-btn.active');
                if (activeCardView) {
                    const viewType = activeCardView.id.replace('view-', '');
                    if (viewType === 'country') {
                        renderByCountry();
                    } else if (viewType === 'category') {
                        renderByCategory();
                    } else if (viewType === 'family') {
                        renderByFamily();
                    }
                }
            }
            
            updateStats();
        }

        function updateGraphFilters() {
            if (!graph || !sigma) return;
            
            // Get filtered actors
            const filteredActors = getFilteredActors();
            const filteredActorNames = new Set(filteredActors.map(actor => `actor_${actor.name}`));
            
            // Get countries and categories that have matching actors
            const visibleCountries = new Set(filteredActors.map(actor => `country_${actor.origin}`));
            const visibleCategories = new Set(filteredActors.map(actor => `category_${actor.category}`));
            
            // Reset all nodes to visible first
            graph.forEachNode((node) => {
                graph.removeNodeAttribute(node, 'hidden');
                // Restore original labels if they were hidden by search
                const originalLabel = graph.getNodeAttribute(node, 'originalLabel');
                if (originalLabel) {
                    graph.setNodeAttribute(node, 'label', originalLabel);
                }
            });
            
            // Hide nodes based on filters
            graph.forEachNode((node) => {
                const nodeData = graph.getNodeAttributes(node);
                let shouldHide = false;
                
                if (nodeData.nodeType === 'actor' && !filteredActorNames.has(node)) {
                    shouldHide = true;
                } else if (nodeData.nodeType === 'country' && !visibleCountries.has(node)) {
                    shouldHide = true;
                } else if (nodeData.nodeType === 'category' && !visibleCategories.has(node)) {
                    shouldHide = true;
                }
                
                if (shouldHide) {
                    // Store original label if not already stored
                    if (!graph.getNodeAttribute(node, 'originalLabel')) {
                        graph.setNodeAttribute(node, 'originalLabel', graph.getNodeAttribute(node, 'label'));
                    }
                    // Hide by setting label to empty and marking as hidden
                    graph.setNodeAttribute(node, 'label', '');
                    graph.setNodeAttribute(node, 'hidden', true);
                }
            });
            
            // Refresh sigma to apply changes
            sigma.refresh();
        }

        function updateStats() {
            const totalActors = threatActorsData ? threatActorsData.threat_actors.length : 0;
            const visibleActors = getFilteredActors().length;
            const totalCountries = threatActorsData ? [...new Set(threatActorsData.threat_actors.map(actor => actor.origin))].filter(country => 
                country && country !== 'Unknown' && !country.includes('motivated') && !country.includes('sector') && !country.includes('operations') && !country.includes('development') && !country.includes('network')
            ).length : 0;

            document.getElementById('totalActors').textContent = totalActors;
            document.getElementById('visibleActors').textContent = visibleActors;
            document.getElementById('totalCountries').textContent = totalCountries;
        }

        // Initialize the application
        // Panel toggle functionality
        function setupPanelToggle() {
            const controlsPanel = document.querySelector('.controls');
            const toggleBtn = document.getElementById('panel-toggle');
            const expandBtn = document.getElementById('panel-expand');
            
            function togglePanel() {
                panelCollapsed = !panelCollapsed;
                
                if (panelCollapsed) {
                    // Collapse panel
                    controlsPanel.classList.add('collapsed');
                    toggleBtn.classList.add('collapsed');
                    expandBtn.style.display = 'flex';
                } else {
                    // Expand panel
                    controlsPanel.classList.remove('collapsed');
                    toggleBtn.classList.remove('collapsed');
                    expandBtn.style.display = 'none';
                }
            }
            
            // Add click handlers
            toggleBtn.onclick = togglePanel;
            expandBtn.onclick = togglePanel;
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, starting application...');
            
            // Check if dependencies are loaded  
            console.log('Checking dependencies...');
            console.log('graphology available:', typeof graphology !== 'undefined');
            console.log('Sigma available:', typeof Sigma !== 'undefined');
            
            if (typeof graphology !== 'undefined') {
                console.log('graphology object:', graphology);
                console.log('graphology.Graph:', typeof graphology.Graph);
            } else {
                console.error('Graphology library failed to load!');
            }
            
            if (typeof Sigma !== 'undefined') {
                console.log('Sigma object:', Sigma);
            } else {
                console.error('Sigma library failed to load!');
            }
            
            // Setup panel toggle functionality
            setupPanelToggle();
            
            loadThreatActorsData();
        });
    </script>
</body>
</html>